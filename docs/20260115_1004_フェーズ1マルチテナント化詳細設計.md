# フェーズ1: マルチテナント化準備 詳細設計手順書

## 目的

複数の利用者（政党・個人議員など）が、公式がホスティングする「まるみえ」に参加できるようにするため。
このフェーズ1では、ダウンタイムなしで実施できるスキーマ変更とデータ準備を行い、マルチテナント化の基盤を整備する。

---

## スコープ

フェーズ1で実施する内容:

1. **スキーマ変更**: 新規テーブル作成、既存テーブルへのカラム追加（NULL許容）
2. **ドメインモデル定義**: Tenant, UserTenantMembership, TenantRole の型・モデル作成
3. **既存データマイグレーション**: 既存データをテナントに紐づけ
4. **NOT NULL制約の追加**: データ移行完了後の制約追加

フェーズ1で実施しない内容:
- RLSポリシーの作成・有効化（フェーズ3）
- admin アプリのURL構造変更（フェーズ2）
- テナント選択画面・メンバー管理画面の実装（フェーズ2）

---

## 前提条件

- 既存の本番環境が稼働中
- 単一テナント（政党）のデータが存在
- ダウンタイムを発生させない

---

## 1. スキーマ変更

### 1.1 Prismaスキーマの変更

`prisma/schema.prisma` に以下の変更を加える。

#### 1.1.1 新規モデル: Tenant

```prisma
model Tenant {
  id          BigInt   @id @default(autoincrement())
  name        String   @db.VarChar(100)
  slug        String   @unique @db.VarChar(50)
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  politicalOrganizations PoliticalOrganization[]
  counterparts           Counterpart[]
  donors                 Donor[]
  memberships            UserTenantMembership[]

  @@map("tenants")
}
```

#### 1.1.2 新規モデル: UserTenantMembership

```prisma
model UserTenantMembership {
  id        BigInt   @id @default(autoincrement())
  userId    String   @map("user_id")
  tenantId  BigInt   @map("tenant_id")
  role      TenantRole @default(editor)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@map("user_tenant_memberships")
}

enum TenantRole {
  owner
  admin
  editor
}
```

#### 1.1.3 既存モデルの変更: User

```prisma
model User {
  id        String   @id @default(uuid())
  authId    String   @unique @map("auth_id")
  email     String   @unique @db.VarChar(255)
  role      UserRole @default(user)  // 将来削除予定だが、フェーズ1では維持
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // 追加
  tenantMemberships UserTenantMembership[]

  @@map("users")
}
```

#### 1.1.4 既存モデルの変更: PoliticalOrganization

```prisma
model PoliticalOrganization {
  id               BigInt            @id @default(autoincrement())
  displayName      String            @map("display_name") @db.VarChar(255)
  description      String?
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")
  slug             String            @unique @db.VarChar(255)
  orgName          String?           @map("org_name") @db.VarChar(255)

  // 追加（フェーズ1ではNULL許容、フェーズ1完了後にNOT NULL化）
  tenantId         BigInt?           @map("tenant_id")
  tenant           Tenant?           @relation(fields: [tenantId], references: [id])

  balanceSnapshots BalanceSnapshot[]
  reportProfiles   OrganizationReportProfile[]
  transactions     Transaction[]

  @@index([tenantId])
  @@map("political_organizations")
}
```

#### 1.1.5 既存モデルの変更: Counterpart

```prisma
model Counterpart {
  id         BigInt   @id @default(autoincrement())
  name       String   @db.VarChar(120)
  postalCode String?  @db.VarChar(10) @map("postal_code")
  address    String?  @db.VarChar(120)
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // 追加（フェーズ1ではNULL許容、フェーズ1完了後にNOT NULL化）
  tenantId  BigInt?  @map("tenant_id")
  tenant    Tenant?  @relation(fields: [tenantId], references: [id])

  transactionCounterparts TransactionCounterpart[]

  @@unique([name, address])
  @@index([tenantId])
  @@map("counterparts")
}
```

#### 1.1.6 既存モデルの変更: Donor

```prisma
model Donor {
  id                BigInt            @id @default(autoincrement())
  donorType         DonorType         @map("donor_type")
  name              String            @db.VarChar(120)
  address           String?           @db.VarChar(120)
  occupation        String?           @db.VarChar(50)
  createdAt         DateTime          @default(now()) @map("created_at")
  updatedAt         DateTime          @updatedAt @map("updated_at")

  // 追加（フェーズ1ではNULL許容、フェーズ1完了後にNOT NULL化）
  tenantId          BigInt?           @map("tenant_id")
  tenant            Tenant?           @relation(fields: [tenantId], references: [id])

  transactionDonors TransactionDonor[]

  @@unique([name, address, donorType])
  @@index([tenantId])
  @@map("donors")
}
```

### 1.2 マイグレーション実行

```bash
# マイグレーションファイルの生成
pnpm prisma migrate dev --name add_multi_tenant_tables

# 本番環境へのマイグレーション適用
pnpm prisma migrate deploy
```

---

## 2. ドメインモデル定義

### 2.1 TenantRole ドメインモデル

**ファイル**: `admin/src/server/contexts/auth/domain/models/tenant-role.ts`

```typescript
/**
 * テナントロール（ドメイン層の型定義）
 *
 * const配列 + 型ガード パターンで実装
 * - 新規実装では interface + const パターンを使用するが、
 *   enumはPrismaスキーマと同期するため特別扱い
 */

/** テナントロールの値一覧 */
export const TENANT_ROLES = ["owner", "admin", "editor"] as const;

/** テナントロール型 */
export type TenantRole = (typeof TENANT_ROLES)[number];

/**
 * TenantRole のドメインモデル
 */
export const TenantRoleModel = {
  /**
   * 値がTenantRoleかどうかを検証
   */
  isTenantRole(value: unknown): value is TenantRole {
    return (
      typeof value === "string" &&
      TENANT_ROLES.includes(value as TenantRole)
    );
  },

  /**
   * 指定されたロールが必要な権限を持っているか判定
   * @param currentRole 現在のロール
   * @param requiredRole 必要なロール
   */
  hasPermission(currentRole: TenantRole, requiredRole: TenantRole): boolean {
    const hierarchy: Record<TenantRole, number> = {
      owner: 3,
      admin: 2,
      editor: 1,
    };
    return hierarchy[currentRole] >= hierarchy[requiredRole];
  },

  /**
   * owner権限を持っているか判定
   */
  isOwner(role: TenantRole): boolean {
    return role === "owner";
  },

  /**
   * admin以上の権限を持っているか判定
   */
  isAdminOrAbove(role: TenantRole): boolean {
    return role === "owner" || role === "admin";
  },
} as const;
```

### 2.2 Tenant ドメインモデル

**ファイル**: `admin/src/server/contexts/auth/domain/models/tenant.ts`

```typescript
import "server-only";

/**
 * テナント（契約・管理単位）
 * 政党や個人議員事務所など、利用者の最上位の管理単位
 */
export interface Tenant {
  id: bigint;
  name: string;
  slug: string;
  description: string | null;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Tenant のドメインモデル
 */
export const TenantModel = {
  /**
   * slug のバリデーション
   * - 英小文字、数字、ハイフンのみ
   * - 3〜50文字
   */
  validateSlug(slug: string): { valid: boolean; message?: string } {
    if (slug.length < 3 || slug.length > 50) {
      return { valid: false, message: "slugは3〜50文字で指定してください" };
    }
    if (!/^[a-z0-9-]+$/.test(slug)) {
      return {
        valid: false,
        message: "slugは英小文字、数字、ハイフンのみ使用できます",
      };
    }
    if (slug.startsWith("-") || slug.endsWith("-")) {
      return {
        valid: false,
        message: "slugの先頭・末尾にハイフンは使用できません",
      };
    }
    return { valid: true };
  },
} as const;
```

### 2.3 UserTenantMembership ドメインモデル

**ファイル**: `admin/src/server/contexts/auth/domain/models/user-tenant-membership.ts`

```typescript
import "server-only";

import type { TenantRole } from "@/server/contexts/auth/domain/models/tenant-role";

/**
 * ユーザーとテナントの関連（メンバーシップ）
 */
export interface UserTenantMembership {
  id: bigint;
  userId: string;
  tenantId: bigint;
  role: TenantRole;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * テナントメンバーシップ情報（テナント詳細を含む）
 */
export interface TenantMembershipWithTenant {
  membership: UserTenantMembership;
  tenantSlug: string;
  tenantName: string;
}
```

---

## 3. リポジトリインターフェース定義

### 3.1 TenantRepository インターフェース

**ファイル**: `admin/src/server/contexts/auth/domain/repositories/tenant-repository.interface.ts`

```typescript
import "server-only";

import type { Tenant } from "@/server/contexts/auth/domain/models/tenant";

/**
 * テナント作成時の入力
 */
export interface CreateTenantInput {
  name: string;
  slug: string;
  description?: string;
}

/**
 * テナントリポジトリインターフェース
 */
export interface TenantRepository {
  /**
   * IDでテナントを取得
   */
  findById(id: bigint): Promise<Tenant | null>;

  /**
   * slugでテナントを取得
   */
  findBySlug(slug: string): Promise<Tenant | null>;

  /**
   * テナントを作成
   */
  create(input: CreateTenantInput): Promise<Tenant>;

  /**
   * テナントを更新
   */
  update(id: bigint, input: Partial<CreateTenantInput>): Promise<Tenant>;
}
```

### 3.2 UserTenantMembershipRepository インターフェース

**ファイル**: `admin/src/server/contexts/auth/domain/repositories/user-tenant-membership-repository.interface.ts`

```typescript
import "server-only";

import type { TenantRole } from "@/server/contexts/auth/domain/models/tenant-role";
import type {
  UserTenantMembership,
  TenantMembershipWithTenant,
} from "@/server/contexts/auth/domain/models/user-tenant-membership";

/**
 * メンバーシップ作成時の入力
 */
export interface CreateMembershipInput {
  userId: string;
  tenantId: bigint;
  role: TenantRole;
}

/**
 * ユーザー・テナントメンバーシップリポジトリインターフェース
 */
export interface UserTenantMembershipRepository {
  /**
   * ユーザーの所属テナント一覧を取得
   */
  findByUserId(userId: string): Promise<TenantMembershipWithTenant[]>;

  /**
   * テナントのメンバー一覧を取得
   */
  findByTenantId(tenantId: bigint): Promise<UserTenantMembership[]>;

  /**
   * 特定のユーザー・テナントの組み合わせでメンバーシップを取得
   */
  findByUserAndTenant(
    userId: string,
    tenantId: bigint
  ): Promise<UserTenantMembership | null>;

  /**
   * メンバーシップを作成
   */
  create(input: CreateMembershipInput): Promise<UserTenantMembership>;

  /**
   * メンバーシップのロールを更新
   */
  updateRole(id: bigint, role: TenantRole): Promise<UserTenantMembership>;

  /**
   * メンバーシップを削除
   */
  delete(id: bigint): Promise<void>;
}
```

---

## 4. リポジトリ実装

### 4.1 PrismaTenantRepository

**ファイル**: `admin/src/server/contexts/auth/infrastructure/repositories/prisma-tenant.repository.ts`

```typescript
import "server-only";

import type {
  CreateTenantInput,
  TenantRepository,
} from "@/server/contexts/auth/domain/repositories/tenant-repository.interface";
import type { Tenant } from "@/server/contexts/auth/domain/models/tenant";
import { prisma } from "@/server/contexts/shared/infrastructure/prisma";

/**
 * Prisma実装のテナントリポジトリ
 */
export class PrismaTenantRepository implements TenantRepository {
  async findById(id: bigint): Promise<Tenant | null> {
    const tenant = await prisma.tenant.findUnique({
      where: { id },
    });
    return tenant;
  }

  async findBySlug(slug: string): Promise<Tenant | null> {
    const tenant = await prisma.tenant.findUnique({
      where: { slug },
    });
    return tenant;
  }

  async create(input: CreateTenantInput): Promise<Tenant> {
    const tenant = await prisma.tenant.create({
      data: {
        name: input.name,
        slug: input.slug,
        description: input.description ?? null,
      },
    });
    return tenant;
  }

  async update(
    id: bigint,
    input: Partial<CreateTenantInput>
  ): Promise<Tenant> {
    const tenant = await prisma.tenant.update({
      where: { id },
      data: {
        ...(input.name !== undefined && { name: input.name }),
        ...(input.slug !== undefined && { slug: input.slug }),
        ...(input.description !== undefined && {
          description: input.description,
        }),
      },
    });
    return tenant;
  }
}
```

### 4.2 PrismaUserTenantMembershipRepository

**ファイル**: `admin/src/server/contexts/auth/infrastructure/repositories/prisma-user-tenant-membership.repository.ts`

```typescript
import "server-only";

import type {
  CreateMembershipInput,
  UserTenantMembershipRepository,
} from "@/server/contexts/auth/domain/repositories/user-tenant-membership-repository.interface";
import type {
  UserTenantMembership,
  TenantMembershipWithTenant,
} from "@/server/contexts/auth/domain/models/user-tenant-membership";
import type { TenantRole } from "@/server/contexts/auth/domain/models/tenant-role";
import { prisma } from "@/server/contexts/shared/infrastructure/prisma";

/**
 * Prisma実装のユーザー・テナントメンバーシップリポジトリ
 */
export class PrismaUserTenantMembershipRepository
  implements UserTenantMembershipRepository
{
  async findByUserId(userId: string): Promise<TenantMembershipWithTenant[]> {
    const memberships = await prisma.userTenantMembership.findMany({
      where: { userId },
      include: {
        tenant: {
          select: {
            slug: true,
            name: true,
          },
        },
      },
      orderBy: { createdAt: "asc" },
    });

    return memberships.map((m) => ({
      membership: {
        id: m.id,
        userId: m.userId,
        tenantId: m.tenantId,
        role: m.role as TenantRole,
        createdAt: m.createdAt,
        updatedAt: m.updatedAt,
      },
      tenantSlug: m.tenant.slug,
      tenantName: m.tenant.name,
    }));
  }

  async findByTenantId(tenantId: bigint): Promise<UserTenantMembership[]> {
    const memberships = await prisma.userTenantMembership.findMany({
      where: { tenantId },
      orderBy: { createdAt: "asc" },
    });

    return memberships.map((m) => ({
      id: m.id,
      userId: m.userId,
      tenantId: m.tenantId,
      role: m.role as TenantRole,
      createdAt: m.createdAt,
      updatedAt: m.updatedAt,
    }));
  }

  async findByUserAndTenant(
    userId: string,
    tenantId: bigint
  ): Promise<UserTenantMembership | null> {
    const membership = await prisma.userTenantMembership.findUnique({
      where: {
        userId_tenantId: { userId, tenantId },
      },
    });

    if (!membership) return null;

    return {
      id: membership.id,
      userId: membership.userId,
      tenantId: membership.tenantId,
      role: membership.role as TenantRole,
      createdAt: membership.createdAt,
      updatedAt: membership.updatedAt,
    };
  }

  async create(input: CreateMembershipInput): Promise<UserTenantMembership> {
    const membership = await prisma.userTenantMembership.create({
      data: {
        userId: input.userId,
        tenantId: input.tenantId,
        role: input.role,
      },
    });

    return {
      id: membership.id,
      userId: membership.userId,
      tenantId: membership.tenantId,
      role: membership.role as TenantRole,
      createdAt: membership.createdAt,
      updatedAt: membership.updatedAt,
    };
  }

  async updateRole(
    id: bigint,
    role: TenantRole
  ): Promise<UserTenantMembership> {
    const membership = await prisma.userTenantMembership.update({
      where: { id },
      data: { role },
    });

    return {
      id: membership.id,
      userId: membership.userId,
      tenantId: membership.tenantId,
      role: membership.role as TenantRole,
      createdAt: membership.createdAt,
      updatedAt: membership.updatedAt,
    };
  }

  async delete(id: bigint): Promise<void> {
    await prisma.userTenantMembership.delete({
      where: { id },
    });
  }
}
```

---

## 5. 既存データマイグレーション

マイグレーション完了後、既存データをテナントに紐づける。
以下のSQLスクリプトを Supabase SQL Editor または Prisma の migrate 内で実行する。

### 5.1 マイグレーションスクリプト

**ファイル**: `prisma/migrations/YYYYMMDDHHMMSS_migrate_existing_data_to_tenant/migration.sql`

```sql
-- ============================================
-- 既存データのテナント紐づけマイグレーション
-- ============================================

-- 1. 既存政党用のテナントを作成
-- ※ slug は実際の政党に合わせて変更すること
INSERT INTO tenants (name, slug, description, created_at, updated_at)
SELECT
  display_name,                              -- テナント名として displayName を使用
  slug,                                       -- 政治団体の slug をそのまま使用
  '既存データから自動作成されたテナント',
  NOW(),
  NOW()
FROM political_organizations
LIMIT 1;  -- 現在は単一テナント想定

-- 2. 作成したテナントのIDを取得して変数に格納（PostgreSQL では DO ブロックを使用）
DO $$
DECLARE
  v_tenant_id BIGINT;
BEGIN
  -- 最初に作成したテナントのIDを取得
  SELECT id INTO v_tenant_id FROM tenants ORDER BY id LIMIT 1;

  -- 3. 既存の political_organizations をテナントに紐づけ
  UPDATE political_organizations
  SET tenant_id = v_tenant_id
  WHERE tenant_id IS NULL;

  -- 4. 既存の counterparts をテナントに紐づけ
  UPDATE counterparts
  SET tenant_id = v_tenant_id
  WHERE tenant_id IS NULL;

  -- 5. 既存の donors をテナントに紐づけ
  UPDATE donors
  SET tenant_id = v_tenant_id
  WHERE tenant_id IS NULL;

  -- 6. 既存ユーザーをテナントに紐づけ（owner として追加）
  INSERT INTO user_tenant_memberships (user_id, tenant_id, role, created_at, updated_at)
  SELECT id, v_tenant_id, 'owner', NOW(), NOW()
  FROM users
  WHERE NOT EXISTS (
    SELECT 1 FROM user_tenant_memberships
    WHERE user_id = users.id AND tenant_id = v_tenant_id
  );
END $$;
```

### 5.2 実行手順

1. **ステージング環境で検証**
   ```bash
   # ステージング環境に接続
   # Supabase SQL Editor で上記スクリプトを実行
   ```

2. **本番環境で実行**
   ```bash
   # 本番環境に接続
   # Supabase SQL Editor で上記スクリプトを実行
   ```

3. **データ確認**
   ```sql
   -- テナントが作成されたか確認
   SELECT * FROM tenants;

   -- political_organizations がテナントに紐づけられたか確認
   SELECT id, display_name, tenant_id FROM political_organizations;

   -- counterparts がテナントに紐づけられたか確認
   SELECT id, name, tenant_id FROM counterparts;

   -- donors がテナントに紐づけられたか確認
   SELECT id, name, tenant_id FROM donors;

   -- ユーザーがテナントに紐づけられたか確認
   SELECT u.email, utm.tenant_id, utm.role
   FROM users u
   JOIN user_tenant_memberships utm ON u.id = utm.user_id;
   ```

---

## 6. NOT NULL制約の追加

データマイグレーション完了後、`tenant_id` カラムに NOT NULL 制約を追加する。

### 6.1 Prismaスキーマの更新

`prisma/schema.prisma` で以下の変更を行う:

```prisma
// PoliticalOrganization
tenantId         BigInt           @map("tenant_id")  // ? を削除
tenant           Tenant           @relation(fields: [tenantId], references: [id])  // ? を削除

// Counterpart
tenantId  BigInt  @map("tenant_id")  // ? を削除
tenant    Tenant  @relation(fields: [tenantId], references: [id])  // ? を削除

// Donor
tenantId          BigInt           @map("tenant_id")  // ? を削除
tenant            Tenant           @relation(fields: [tenantId], references: [id])  // ? を削除
```

### 6.2 マイグレーション実行

```bash
pnpm prisma migrate dev --name make_tenant_id_required
```

このマイグレーションは以下のSQLを生成する:

```sql
-- NOT NULL制約の追加
ALTER TABLE political_organizations ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE counterparts ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE donors ALTER COLUMN tenant_id SET NOT NULL;
```

---

## 7. インデックス作成

パフォーマンス最適化のため、以下のインデックスを作成する。
Prismaスキーマに `@@index` を追加済みのため、マイグレーション時に自動作成される。

```sql
-- 確認用: 作成されるインデックス
CREATE INDEX idx_user_tenant_memberships_user_id ON user_tenant_memberships(user_id);
CREATE INDEX idx_user_tenant_memberships_tenant_id ON user_tenant_memberships(tenant_id);
CREATE INDEX idx_political_organizations_tenant_id ON political_organizations(tenant_id);
CREATE INDEX idx_counterparts_tenant_id ON counterparts(tenant_id);
CREATE INDEX idx_donors_tenant_id ON donors(tenant_id);
```

---

## 8. 実装チェックリスト

### 8.1 スキーマ変更

- [ ] `prisma/schema.prisma` に `Tenant` モデルを追加
- [ ] `prisma/schema.prisma` に `UserTenantMembership` モデルを追加
- [ ] `prisma/schema.prisma` に `TenantRole` enum を追加
- [ ] `prisma/schema.prisma` の `User` モデルに `tenantMemberships` リレーションを追加
- [ ] `prisma/schema.prisma` の `PoliticalOrganization` モデルに `tenantId` カラムを追加（NULL許容）
- [ ] `prisma/schema.prisma` の `Counterpart` モデルに `tenantId` カラムを追加（NULL許容）
- [ ] `prisma/schema.prisma` の `Donor` モデルに `tenantId` カラムを追加（NULL許容）
- [ ] マイグレーション実行: `pnpm prisma migrate dev --name add_multi_tenant_tables`
- [ ] `pnpm prisma generate` でクライアント再生成

### 8.2 ドメインモデル

- [ ] `admin/src/server/contexts/auth/domain/models/tenant-role.ts` を作成
- [ ] `admin/src/server/contexts/auth/domain/models/tenant.ts` を作成
- [ ] `admin/src/server/contexts/auth/domain/models/user-tenant-membership.ts` を作成

### 8.3 リポジトリ

- [ ] `admin/src/server/contexts/auth/domain/repositories/tenant-repository.interface.ts` を作成
- [ ] `admin/src/server/contexts/auth/domain/repositories/user-tenant-membership-repository.interface.ts` を作成
- [ ] `admin/src/server/contexts/auth/infrastructure/repositories/prisma-tenant.repository.ts` を作成
- [ ] `admin/src/server/contexts/auth/infrastructure/repositories/prisma-user-tenant-membership.repository.ts` を作成

### 8.4 既存データマイグレーション

- [ ] ステージング環境でマイグレーションスクリプトを実行
- [ ] データが正しく紐づけられたことを確認
- [ ] 本番環境でマイグレーションスクリプトを実行
- [ ] データが正しく紐づけられたことを確認

### 8.5 NOT NULL制約の追加

- [ ] 全ての既存データに `tenant_id` が設定されていることを確認
- [ ] `prisma/schema.prisma` で `tenantId` を必須に変更（`?` を削除）
- [ ] マイグレーション実行: `pnpm prisma migrate dev --name make_tenant_id_required`

### 8.6 動作確認

- [ ] アプリケーションが正常に起動すること
- [ ] 既存の機能が正常に動作すること（リグレッションなし）
- [ ] Prisma Studio でデータを確認できること

---

## 9. 注意事項

### 9.1 ダウンタイムについて

- スキーマ変更（カラム追加、テーブル作成）はダウンタイムなしで実行可能
- NOT NULL制約の追加は、データが全て揃っていれば数秒で完了
- 万が一問題が発生した場合は、カラムを NULL に戻すことでロールバック可能

### 9.2 既存機能への影響

- フェーズ1では既存のUsecaseやUIは変更しない
- `tenantId` はNULL許容で追加するため、既存のクエリは影響を受けない
- フェーズ2でUsecaseに `tenantId` を必須化する際に、順次対応する

### 9.3 テスト

- マイグレーション後、以下を確認すること:
  - 既存の取引一覧が正常に表示される
  - 既存のCSVインポートが正常に動作する
  - 既存の報告書エクスポートが正常に動作する

---

## 10. 次のフェーズ（フェーズ2）への引き継ぎ事項

フェーズ1完了後、フェーズ2で以下を実施する:

1. **admin アプリのURL構造変更**
   - `/t/[tenantSlug]/o/[orgSlug]/...` 形式への移行

2. **テナントコンテキストの導入**
   - `getCurrentContext()` 関数の実装
   - 全Usecase / Repository への `tenantId` 必須化

3. **UI実装**
   - テナント選択画面
   - 政治団体選択画面
   - メンバー管理画面

---

## 参考資料

- [マルチテナント化概要設計](./20260114_2240_マルチテナント化概要設計.md)
- [バックエンドアーキテクチャガイド](./backend-architecture-guide.md)
