# auth コンテキスト 4レイヤー移行設計

## 1. 概要

auth コンテキストを他コンテキスト（report, data-import）と同様の 4 レイヤー構造（presentation / application / domain / infrastructure）にリファクタリングする。

### 移行前の構造

```
admin/src/server/contexts/auth/
├── application/
│   ├── admin.ts      # Supabase Admin Client 生成
│   ├── client.ts     # Supabase Server Client 生成
│   ├── login.ts      # ログイン・ログアウト・招待セッション処理
│   ├── roles.ts      # ロール取得・権限チェック
│   └── users.ts      # ユーザーCRUD・招待・パスワード設定
└── index.ts          # re-export
```

### 移行後の構造

```
admin/src/server/contexts/auth/
├── domain/
│   ├── models/
│   │   └── auth-user.ts           # AuthUser モデル
│   ├── services/
│   │   └── role-validator.ts      # ロール検証ロジック
│   └── repositories/
│       └── auth-provider.interface.ts  # 認証プロバイダーのインターフェース
├── infrastructure/
│   ├── supabase/
│   │   ├── supabase-client.ts     # Server Client
│   │   └── supabase-admin-client.ts  # Admin Client
│   └── repositories/
│       └── supabase-auth-provider.ts  # Supabase による認証プロバイダー実装
├── application/
│   └── usecases/
│       ├── login-usecase.ts           # ログイン処理
│       ├── logout-usecase.ts          # ログアウト処理
│       ├── get-current-user-usecase.ts   # 現在のユーザー取得
│       ├── require-role-usecase.ts    # ロール検証
│       ├── invite-user-usecase.ts     # ユーザー招待
│       ├── setup-password-usecase.ts  # パスワード設定
│       ├── update-user-role-usecase.ts   # ロール更新
│       └── exchange-code-for-session-usecase.ts  # OAuthコールバック処理
├── presentation/
│   ├── actions/
│   │   ├── login.ts
│   │   ├── logout.ts
│   │   ├── invite-user.ts
│   │   ├── setup-password.ts
│   │   └── update-user-role.ts
│   └── loaders/
│       ├── load-current-user.ts
│       ├── load-current-user-role.ts
│       └── load-all-users.ts
└── index.ts
```

---

## 2. 各レイヤーの責務と配置

### 2.1 domain 層

| ファイル | 責務 |
|---------|------|
| `models/auth-user.ts` | AuthUser 型定義（id, authId, email, role など） |
| `services/role-validator.ts` | ロール検証のビジネスルール（「adminロールが必要な場合、現在のロールがadminであること」など） |
| `repositories/auth-provider.interface.ts` | 認証プロバイダーのインターフェース定義（signIn, signOut, getUser, updatePassword など） |

**ポイント**:
- `User` と `UserRepository` は既に shared コンテキストにあるため、auth 固有のものだけを定義
- auth 固有のドメイン知識（ロール検証ルールなど）を明確化

### 2.2 infrastructure 層

| ファイル | 責務 |
|---------|------|
| `supabase/supabase-client.ts` | Cookie を扱う Supabase Server Client の生成 |
| `supabase/supabase-admin-client.ts` | Service Role Key を使う Admin Client の生成 |
| `repositories/supabase-auth-provider.ts` | `AuthProvider` インターフェースの Supabase 実装 |

**ポイント**:
- 現在の `client.ts` と `admin.ts` を移動
- Supabase Auth API の呼び出しをカプセル化

### 2.3 application 層

| ファイル | 責務 |
|---------|------|
| `usecases/login-usecase.ts` | メール/パスワードでのログイン処理のオーケストレーション |
| `usecases/logout-usecase.ts` | ログアウト処理 |
| `usecases/get-current-user-usecase.ts` | 現在のユーザー取得（Supabase + DB 連携） |
| `usecases/require-role-usecase.ts` | ロール検証（domain service を呼び出し） |
| `usecases/invite-user-usecase.ts` | ユーザー招待（Admin Client 経由） |
| `usecases/setup-password-usecase.ts` | パスワード設定 |
| `usecases/update-user-role-usecase.ts` | ユーザーロール更新（UserRepository 経由） |
| `usecases/exchange-code-for-session-usecase.ts` | OAuth コールバック処理（code → session 交換、ユーザー作成） |

**ポイント**:
- 現在の `roles.ts`, `login.ts`, `users.ts` の関数を Usecase クラスに分解
- Constructor Injection で AuthProvider と UserRepository を受け取る

### 2.4 presentation 層

| ファイル | 責務 |
|---------|------|
| `actions/login.ts` | Server Action: ログインフォーム処理 |
| `actions/logout.ts` | Server Action: ログアウト処理 |
| `actions/invite-user.ts` | Server Action: ユーザー招待 |
| `actions/setup-password.ts` | Server Action: パスワード設定 |
| `actions/update-user-role.ts` | Server Action: ロール更新 |
| `loaders/load-current-user.ts` | ローダー: 現在のユーザー取得 |
| `loaders/load-current-user-role.ts` | ローダー: 現在のユーザーロール取得 |
| `loaders/load-all-users.ts` | ローダー: 全ユーザー一覧取得 |

**ポイント**:
- `"use server"` ディレクティブを持つのは presentation 層のみ
- Usecase のインスタンス化と呼び出しを行う薄いレイヤー
- キャッシング（`unstable_cache`）と再検証（`revalidatePath`）を担当

---

## 3. 移行手順

以下の順序で移行を行う：**domain → infrastructure → application → presentation**

### Step 1: domain 層の作成

1. `auth/domain/models/auth-user.ts` を作成
   - 現在 `index.ts` にある `AuthUser` インターフェースを移動

2. `auth/domain/services/role-validator.ts` を作成
   - `requireRole` のロジック部分（「admin が必要なら admin であること」の判定）を抽出

3. `auth/domain/repositories/auth-provider.interface.ts` を作成
   - Supabase Auth の操作を抽象化したインターフェースを定義
   - エラー時は AuthError を throw（詳細は「6. AuthProvider インターフェース詳細」を参照）
   - 以下のメソッドを定義：
     - `signInWithPassword(email, password): Promise<AuthSession>`
     - `signOut(): Promise<void>`
     - `getUser(): Promise<SupabaseAuthUser | null>`
     - `updateUser(data): Promise<SupabaseAuthUser>`
     - `setSession(accessToken, refreshToken): Promise<AuthSession>`
     - `exchangeCodeForSession(code): Promise<AuthSession>`

4. `auth/domain/errors/auth-error.ts` を作成
   - AuthError クラスと AuthErrorCode 型を定義（詳細は「5.4 AuthError クラスの定義」を参照）

5. `auth/domain/repositories/admin-auth-provider.interface.ts` を作成（Admin 専用操作を分離）
   - `inviteUserByEmail(email, redirectTo): Promise<void>`

### Step 2: infrastructure 層の作成

1. `auth/infrastructure/supabase/supabase-client.ts` を作成
   - 現在の `application/client.ts` を移動

2. `auth/infrastructure/supabase/supabase-admin-client.ts` を作成
   - 現在の `application/admin.ts` を移動

3. `auth/infrastructure/repositories/supabase-auth-provider.ts` を作成
   - `AuthProvider` インターフェースを実装
   - 内部で `supabase-client.ts` と `supabase-admin-client.ts` を使用

### Step 3: application 層の作成

1. 各 Usecase クラスを作成
   - 現在の `login.ts`, `roles.ts`, `users.ts` の各関数を対応する Usecase に変換
   - Constructor Injection パターンを適用

2. 変換マッピング:
   | 現在の関数 | 新しい Usecase |
   |-----------|---------------|
   | `loginWithPassword` | `LoginUsecase.execute(email, password)` |
   | `logout` | `LogoutUsecase.execute()` |
   | `getCurrentUser` | `GetCurrentUserUsecase.execute()` |
   | `getCurrentUserRole` | `GetCurrentUserRoleUsecase.execute()` |
   | `requireRole` | `RequireRoleUsecase.execute(requiredRole)` |
   | `getAllUsers` | `GetAllUsersUsecase.execute()` |
   | `inviteUser` | `InviteUserUsecase.execute(email)` |
   | `setupPassword` | `SetupPasswordUsecase.execute(password)` |
   | `updateUserRole` | `UpdateUserRoleUsecase.execute(userId, role)` |
   | `exchangeCodeForSession` | `ExchangeCodeForSessionUsecase.execute(code)` |
   | `completeInviteSession` | `CompleteInviteSessionUsecase.execute(accessToken, refreshToken)` |

### Step 4: presentation 層の作成

1. `auth/presentation/actions/` に Server Action を作成
   - 各 Action は対応する Usecase をインスタンス化して呼び出す
   - `"use server"` ディレクティブを付与
   - 適切な `revalidatePath` / `revalidateTag` を追加

2. `auth/presentation/loaders/` にローダーを作成
   - 読み取り系の操作をローダーとして分離
   - 必要に応じて `unstable_cache` でキャッシング

### Step 5: index.ts の更新

1. `auth/index.ts` を更新
   - presentation 層の actions と loaders から必要な関数を re-export
   - 型定義は domain 層から re-export
   - 既存の API を維持しつつ、内部実装を新構造に切り替え

### Step 6: 呼び出し元の動作確認

1. 以下の呼び出し元で動作確認:
   - `admin/src/app/(auth)/layout.tsx`
   - `admin/src/app/(auth)/users/page.tsx`
   - `admin/src/app/(auth)/user-info/page.tsx`
   - `admin/src/app/(public)/login/page.tsx`
   - `admin/src/app/(public)/auth/callback/route.ts`
   - `admin/src/app/(public)/auth/setup/page.tsx`
   - `admin/src/app/api/` 配下の各 route

2. index.ts の re-export により、呼び出し元の変更は最小限に抑える

### Step 7: クリーンアップ

1. 旧 `application/` ディレクトリ内の移行済みファイルを削除
2. 不要になった import を整理

---

## 4. 設計上の考慮事項

### 4.1 shared コンテキストとの関係

- `User` モデルと `UserRepository` は shared コンテキストに既存
- auth コンテキストは shared の UserRepository を利用する（依存ルールに準拠）
- auth 固有の `AuthUser` 型は、Supabase Auth のユーザー情報を表現するために別途定義

### 4.2 middleware.ts との関係

- `middleware.ts` は Supabase クライアントを直接生成している（Edge Runtime 制約のため）
- middleware は auth コンテキストを直接参照しないため、今回のリファクタリングの影響を受けない

### 4.3 後方互換性

- `index.ts` の export インターフェースを維持
- 呼び出し元コードは変更不要（同じ関数名・シグネチャを維持）

### 4.4 段階的移行

- 各ステップ完了後に動作確認を行い、問題があれば修正
- 一度に全体を移行せず、レイヤーごとに確実に進める

---

## 5. エラーハンドリング設計

admin-architecture-guide.md のエラーハンドリング規約に準拠しつつ、auth コンテキスト固有の詳細を定義する。

### 5.1 原理原則

| 原則 | 説明 |
|-----|------|
| **エラー情報の段階的抽象化** | 下位層（Infrastructure）→ 上位層（Presentation）に向かってエラー情報を段階的に抽象化する。技術的詳細は下位層に留め、上位層ではユーザー理解可能な情報のみを伝える |
| **セキュリティ情報の秘匿** | 認証エラーの詳細（「ユーザーが存在しない」vs「パスワードが違う」）は攻撃者に有用な情報となるため、Presentation 層では汎用メッセージに統一する |
| **ログと UI の分離** | 詳細なエラー情報はサーバーログに記録し、ユーザーには簡潔なメッセージのみを表示する |
| **カスタムエラークラス + throw** | admin-architecture-guide.md に準拠し、Application 層では `throw new AuthError(code, message)` パターンを使用。Presentation 層で `instanceof` と `code` で分岐する |

### 5.2 各レイヤーのエラーハンドリング責務

#### Infrastructure 層

**責務**: 外部サービス（Supabase）のエラーをキャッチし、AuthError として throw する

**詳細度**: 技術的な詳細を含む（デバッグ用）

```typescript
// Supabase のエラーをキャッチして AuthError を throw
async signInWithPassword(email: string, password: string): Promise<AuthSession> {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) {
      throw new AuthError("AUTH_FAILED", error.message, error);
    }
    return mapToAuthSession(data);
  } catch (e) {
    if (e instanceof AuthError) throw e;
    throw new AuthError("NETWORK_ERROR", "認証サービスに接続できません", e);
  }
}
```

**エラーコード例**:
- `AUTH_FAILED`: 認証失敗（Supabase からのエラー）
- `NETWORK_ERROR`: ネットワークエラー
- `SESSION_EXPIRED`: セッション期限切れ
- `INVALID_TOKEN`: 無効なトークン

#### Application 層（Usecase）

**責務**: Infrastructure 層のエラーを受け取り、ビジネスコンテキストを付加して再 throw する

**詳細度**: ビジネス操作の文脈を含む（「ログイン処理に失敗」など）

```typescript
// Usecase での処理（admin-architecture-guide.md 準拠の throw パターン）
async execute(email: string, password: string): Promise<AuthSession> {
  try {
    return await this.authProvider.signInWithPassword(email, password);
  } catch (e) {
    // ログに詳細を記録
    console.error(`Login failed for ${email}:`, e);
    // ビジネスコンテキストを付加して再 throw
    if (e instanceof AuthError) {
      throw new AuthError(e.code, `Failed to login: ${e.message}`, e);
    }
    throw new AuthError("AUTH_FAILED", `Failed to login: ${String(e)}`, e);
  }
}
```

**ロギング**: Application 層でエラーの詳細をサーバーログに記録する（cause を含む）

#### Domain 層（Services）

**責務**: ビジネスルール違反を検出し、構造化されたエラーを返す

**詳細度**: ビジネスルールの観点からの説明

```
// RoleValidator でのエラー
function validateRole(currentRole: UserRole, requiredRole: UserRole): RoleValidationResult {
  if (requiredRole === "admin" && currentRole !== "admin") {
    return { valid: false, reason: "INSUFFICIENT_PERMISSION" };
  }
  return { valid: true };
}
```

#### Presentation 層（Actions/Loaders）

**責務**: エラーを catch してユーザー向けメッセージに変換し、UI が処理可能な形式で返す

**詳細度**: ユーザーが理解・対処可能な情報のみ

```typescript
// Action でのエラー処理（instanceof + code で分岐）
export async function loginAction(email: string, password: string) {
  try {
    await usecase.execute(email, password);
    return { ok: true };
  } catch (e) {
    if (e instanceof AuthError) {
      // code で分岐してユーザー向けメッセージに変換
      const userMessage = AUTH_ERROR_MESSAGES[e.code] ?? "エラーが発生しました";
      return { ok: false, error: userMessage };
    }
    // 予期しないエラー
    return { ok: false, error: "エラーが発生しました" };
  }
}
```

### 5.3 auth コンテキスト固有のエラーメッセージ変換表

| 内部エラーコード | ユーザー向けメッセージ | 備考 |
|----------------|---------------------|------|
| `AUTH_FAILED` | "メールアドレスまたはパスワードが正しくありません" | 存在しないユーザーとパスワード誤りを区別しない |
| `SESSION_EXPIRED` | "セッションの有効期限が切れました。再度ログインしてください" | |
| `INVALID_TOKEN` | "認証情報が無効です。再度ログインしてください" | |
| `NETWORK_ERROR` | "認証サービスに接続できませんでした。しばらく待ってから再試行してください" | |
| `INSUFFICIENT_PERMISSION` | "この操作を行う権限がありません" | |
| `USER_NOT_FOUND` | "ユーザーが見つかりません" | ユーザー管理画面でのみ使用（ログインでは使用しない） |
| `INVALID_EMAIL` | "有効なメールアドレスを入力してください" | バリデーションエラー |
| `WEAK_PASSWORD` | "パスワードは6文字以上で入力してください" | バリデーションエラー |
| `INVITE_FAILED` | "招待メールの送信に失敗しました" | |

### 5.4 AuthError クラスの定義

```typescript
// domain/errors/auth-error.ts

// エラーコードの型定義（網羅性チェック用）
type AuthErrorCode =
  | "AUTH_FAILED"
  | "SESSION_EXPIRED"
  | "INVALID_TOKEN"
  | "NETWORK_ERROR"
  | "INSUFFICIENT_PERMISSION"
  | "USER_NOT_FOUND"
  | "INVALID_EMAIL"
  | "WEAK_PASSWORD"
  | "INVITE_FAILED";

// カスタムエラークラス（単一クラス + code パターン）
class AuthError extends Error {
  constructor(
    public readonly code: AuthErrorCode,
    message: string,
    public readonly cause?: unknown
  ) {
    super(message);
    this.name = "AuthError";
  }
}

// ユーザー向けメッセージ変換マップ（Presentation 層で使用）
const AUTH_ERROR_MESSAGES: Record<AuthErrorCode, string> = {
  AUTH_FAILED: "メールアドレスまたはパスワードが正しくありません",
  SESSION_EXPIRED: "セッションの有効期限が切れました。再度ログインしてください",
  INVALID_TOKEN: "認証情報が無効です。再度ログインしてください",
  NETWORK_ERROR: "認証サービスに接続できませんでした。しばらく待ってから再試行してください",
  INSUFFICIENT_PERMISSION: "この操作を行う権限がありません",
  USER_NOT_FOUND: "ユーザーが見つかりません",
  INVALID_EMAIL: "有効なメールアドレスを入力してください",
  WEAK_PASSWORD: "パスワードは6文字以上で入力してください",
  INVITE_FAILED: "招待メールの送信に失敗しました",
};
```

**ポイント**:
- 単一クラス + `code` プロパティで分岐（クラス数の爆発を防ぐ）
- `instanceof AuthError` で認証エラーかどうかを判定
- `e.code` の switch で網羅性チェック（TypeScript の exhaustive check が効く）
- `cause` で元のエラーを保持（ログ用）

---

## 6. AuthProvider インターフェース詳細

### 6.1 インターフェース分離

通常の認証操作と Admin 専用操作を分離する。エラー時は AuthError を throw する（Result 型ではなく throw パターン）。

```typescript
// domain/repositories/auth-provider.interface.ts
// エラー時は AuthError を throw
interface AuthProvider {
  signInWithPassword(email: string, password: string): Promise<AuthSession>;
  signOut(): Promise<void>;
  getUser(): Promise<SupabaseAuthUser | null>;
  updateUser(data: { password?: string }): Promise<SupabaseAuthUser>;
  setSession(accessToken: string, refreshToken: string): Promise<AuthSession>;
  exchangeCodeForSession(code: string): Promise<AuthSession>;
}

// domain/repositories/admin-auth-provider.interface.ts
interface AdminAuthProvider {
  inviteUserByEmail(email: string, redirectTo: string): Promise<void>;
}
```

### 6.2 戻り値の型定義

```typescript
// domain/models/auth-session.ts
interface AuthSession {
  accessToken: string;
  refreshToken: string;
  user: SupabaseAuthUser;
}

// domain/models/supabase-auth-user.ts
// Supabase Auth から取得されるユーザー情報（DB の User とは別）
interface SupabaseAuthUser {
  id: string;           // Supabase Auth の user ID（= User.authId）
  email: string | null;
  emailConfirmedAt: string | null;
  lastSignInAt: string | null;
}
```

### 6.3 型マッピング

| Supabase 型 | Domain 型 | 備考 |
|------------|----------|------|
| `User` (Supabase Auth) | `SupabaseAuthUser` | 認証プロバイダーから取得されるユーザー |
| `Session` (Supabase Auth) | `AuthSession` | トークン情報を含むセッション |
| `User` (Prisma/DB) | `User` (shared) | DB に永続化されたユーザー |

**変換フロー**:
1. `AuthProvider.getUser()` → `SupabaseAuthUser` を取得
2. `SupabaseAuthUser.id` を使って `UserRepository.findByAuthId()` → `User` を取得
3. Usecase は両方の情報を組み合わせて処理

---

## 7. 成果物一覧

移行完了後のファイル構成:

```
admin/src/server/contexts/auth/
├── domain/
│   ├── models/
│   │   ├── auth-user.ts
│   │   ├── auth-session.ts
│   │   └── supabase-auth-user.ts
│   ├── errors/
│   │   └── auth-error.ts                # AuthError, AuthErrorCode, AUTH_ERROR_MESSAGES
│   ├── services/
│   │   └── role-validator.ts
│   └── repositories/
│       ├── auth-provider.interface.ts
│       └── admin-auth-provider.interface.ts
├── infrastructure/
│   ├── supabase/
│   │   ├── supabase-client.ts
│   │   └── supabase-admin-client.ts
│   └── repositories/
│       └── supabase-auth-provider.ts
├── application/
│   └── usecases/
│       ├── login-usecase.ts
│       ├── logout-usecase.ts
│       ├── get-current-user-usecase.ts
│       ├── get-current-user-role-usecase.ts
│       ├── require-role-usecase.ts
│       ├── get-all-users-usecase.ts
│       ├── invite-user-usecase.ts
│       ├── setup-password-usecase.ts
│       ├── update-user-role-usecase.ts
│       ├── exchange-code-for-session-usecase.ts
│       └── complete-invite-session-usecase.ts
├── presentation/
│   ├── actions/
│   │   ├── login.ts
│   │   ├── logout.ts
│   │   ├── invite-user.ts
│   │   ├── setup-password.ts
│   │   ├── update-user-role.ts
│   │   └── complete-invite-session.ts
│   └── loaders/
│       ├── load-current-user.ts
│       ├── load-current-user-role.ts
│       └── load-all-users.ts
└── index.ts
```
