# 寄附明細5万円超ルール実装設計

## 概要

SYUUSHI07_07（第14号様式 その7）における寄附の明細記載ルールを実装する。

**仕様**（[docs/reference/report-format.md](docs/reference/report-format.md) より）:
- 同一者からの年間5万円を超える寄附は個別に明細を記載する
- その他の寄附（SONOTA_GK）の欄には、明細を記載したもの以外の寄附の合計額を記載する

## 現状の課題

[donation-transaction.ts:144](admin/src/server/contexts/report/domain/models/donation-transaction.ts#L144) において、`sonotaGk` が常に0にハードコードされている：

```typescript
return {
  totalAmount,
  sonotaGk: 0, // その他の寄附は現時点では0
  rows,
};
```

現在は全ての寄附が明細行として出力されており、「同一者からの年間5万円以下の寄附を合算する」ロジックが未実装。

## 設計方針

### アーキテクチャ原則に基づくロジック配置

[admin-architecture-guide.md](docs/admin-architecture-guide.md) のロジック配置判断フローチャートに従う:

> ドメインロジック（ビジネスルール・ドメイン知識）？ → Yes → 複数エンティティにまたがる or 外部データとの照合？ → No → **Domain Model に実装**

「年間5万円を超える寄附を明細に記載し、それ以下を合算する」は政治資金報告書の仕様に基づく**ビジネスルール**であり、単一のセクション（PersonalDonationSection）内で完結するため、**Domain Model**に実装する。

### 設計上の意思決定

#### 1. 同一者判定のキー: donorId を使用

**決定**: 寄附者の同一性判定には `donorName` ではなく `donorId`（Donor テーブルの主キー）を使用する。

**理由**:
- 名前だけでは同姓同名を区別できない
- Donor テーブルで名寄せが管理されており、ID で判定する方が精度が高い

#### 2. グループ化の実装場所: ドメイン層

**決定**: donorId によるグループ化と年間合計の算出はドメイン層（`PersonalDonationSection.fromTransactions`）で行う。

**検討した代替案**:
- SQL層（リポジトリ）でウィンドウ関数を使ってグループ集計する案

**採用しなかった理由**:
- 「年間5万円超で明細記載」は政治資金報告書のビジネスルールであり、Infrastructure層に配置するとドメイン知識が漏れ出す
- リポジトリはデータ取得に徹し、ビジネスロジックはドメイン層に集約する方がアーキテクチャガイドに準拠
- 多少の非効率（全件取得後にアプリケーション側でグループ化）よりも、責務の分離を優先

### 変更対象

| レイヤー | ファイル | 変更内容 |
|---------|---------|---------|
| Domain | `donation-transaction.ts` | `PersonalDonationTransaction`に`donorId`追加 |
| Domain | `donation-transaction.ts` | `fromTransactions`でdonorIdによるグループ化・閾値判定ロジック追加 |
| Application | `donation-assembler.ts` | 変更なし（ドメインロジックに委譲済み） |
| Infrastructure | `prisma-report-transaction.repository.ts` | `donorId`を取得するよう修正 |

## 詳細設計

### 1. PersonalDonationTransaction への donorId 追加

現在の`PersonalDonationTransaction`インターフェースに`donorId`を追加する。

```typescript
export interface PersonalDonationTransaction {
  transactionNo: string;
  transactionDate: Date;
  debitAmount: number;
  creditAmount: number;
  memo: string | null;
  donorId: string | null;    // ← 追加: Donor.id（未紐付けの場合はnull）
  donorName: string;
  donorAddress: string;
  donorOccupation: string;
}
```

### 2. リポジトリ実装の修正

[prisma-report-transaction.repository.ts](admin/src/server/contexts/report/infrastructure/repositories/prisma-report-transaction.repository.ts) の `findPersonalDonationTransactions` で `donorId` を取得するよう修正。

```
マッピング変更:
- donorId: t.transactionDonors[0]?.donor.id.toString() ?? null
```

リポジトリはデータ取得のみを担当し、グループ化・閾値判定のビジネスロジックはドメイン層に委譲する。

### 3. PersonalDonationSection.fromTransactions の変更

#### 処理フロー

```
1. トランザクションを donorId でグループ化（Map<donorId, transactions[]>）
2. 各グループの年間合計金額を算出
3. 年間合計 > 50,000円 のグループ → 各取引を個別に明細行（rows）に展開
4. 年間合計 <= 50,000円 のグループ → グループ全体の金額を sonotaGk に合算
5. totalAmount = 明細行の合計 + sonotaGk
```

#### グループ化の考慮事項

- **同一者の判定**: `donorId` をキーとしてグループ化
  - DonorテーブルのIDで同一者を判定するため、名寄せの精度が向上
  - `donorId === null`（未紐付け）の取引は、各取引を別人として扱う（nullは同一グループとみなさない）

- **グループ内の複数取引**: 5万円超の寄附者からの取引は、個別の取引ごとに明細行を生成する
  - 例: 田中太郎（donorId: 123）から30,000円×3回 = 90,000円 → 3件の明細行として出力
  - 日付・金額等の情報を保持したまま出力するため、グループ化後も個別取引を維持

#### ヘルパー関数の追加

`PersonalDonationSection` namespace 内に以下を追加：

```
groupByDonorId(transactions): Map<string, PersonalDonationTransaction[]>
  - donorIdをキーにグループ化
  - donorId !== null の場合: donorIdをそのままキーとして使用
  - donorId === null の場合: `__unassigned_${index}` 形式のユニークキーを生成し、各取引を別グループとして扱う
    （indexはトランザクション配列内の位置。これにより未紐付け取引は合算されず個別に判定される）

calculateGroupTotal(transactions): number
  - グループ内の取引金額合計を算出
```

**null donorId の扱いについて**:
未紐付け（donorId === null）の取引は、寄附者情報が確定していないため同一者として合算すべきではない。各取引を独立した寄附者として扱い、個別に5万円超の閾値判定を行う。将来的にDonor紐付け機能で解消されることを想定。

#### データ構造の変更なし

`PersonalDonationSection` インターフェースは変更不要：

```typescript
export interface PersonalDonationSection {
  totalAmount: number; // 合計（変更なし）
  sonotaGk: number;    // その他の寄附（ロジック変更で値が入るようになる）
  rows: PersonalDonationRow[];  // 5万円超の寄附者の明細のみ
}
```

### 4. 定数の追加

```typescript
// 寄附明細記載閾値（年間5万円超で明細記載）
export const DONATION_DETAIL_THRESHOLD = 50000;
```

### 5. fromTransactions の変更後の動作

#### 入力例（リポジトリから返却されるデータ）

| donorId | donorName | 金額 | transactionDate |
|---------|-----------|------|-----------------|
| 123 | 田中太郎 | 30,000 | 2024-04-01 |
| 123 | 田中太郎 | 40,000 | 2024-06-15 |
| 456 | 鈴木花子 | 25,000 | 2024-05-01 |
| 789 | 佐藤一郎 | 20,000 | 2024-07-01 |

#### ドメイン層でのグループ化・閾値判定

| donorId | donorName | グループ年間合計 | 閾値判定 |
|---------|-----------|-----------------|----------|
| 123 | 田中太郎 | 70,000 | > 50,000 → 明細（2件） |
| 456 | 鈴木花子 | 25,000 | <= 50,000 → その他 |
| 789 | 佐藤一郎 | 20,000 | <= 50,000 → その他 |

#### 出力

```
totalAmount: 115,000
sonotaGk: 45,000 (鈴木花子 + 佐藤一郎)
rows: [
  { kifusyaNm: "田中太郎", kingaku: 30000, ... },
  { kifusyaNm: "田中太郎", kingaku: 40000, ... },
]
```

## テスト方針

### donation-transaction.test.ts に追加するテストケース

1. **基本ケース**
   - 5万円超の寄附者のみ → 全件が明細、sonotaGk = 0
   - 5万円以下の寄附者のみ → 明細なし、sonotaGk = 全額
   - 混在ケース → 上記の出力例の通り

2. **境界値テスト**
   - 年間ちょうど50,000円 → その他に合算
   - 年間50,001円 → 明細に記載

3. **エッジケース**
   - 空のトランザクションリスト → totalAmount = 0, sonotaGk = 0, rows = []
   - 同一者からの複数取引（5万円超）→ 複数の明細行
   - donorName が空文字の取引 → 各取引を別人として扱う

4. **合計額の整合性**
   - totalAmount === 明細行の合計 + sonotaGk

## 影響範囲

### 変更が不要な箇所

- **donation-assembler.ts**: ドメインロジックに委譲しているため変更不要
- **donation-serializer.ts**: 既に `sonotaGk > 0` の場合の出力に対応済み
- **XMLエクスポート**: serializerが対応済みのため変更不要

### 変更が必要だがビジネスロジックに影響しない箇所

- **prisma-report-transaction.repository.ts**: `donorId`取得のためのマッピング追加が必要（ビジネスロジックの変更なし、データ取得の拡張のみ）

### 既存テストへの影響

- **donation-assembler.test.ts**: モックの戻り値を使用しているため、ドメインロジックの変更により一部テストケースの期待値を修正する必要あり
  - 特に `sonotaGk` が常に0であることを前提としたテストがある場合

## 対象外（スコープ外）

- 法人からの寄附（KUBUN2）、政治団体からの寄附（KUBUN3）の同様の処理
- 寄附のあっせん（SYUUSHI07_08）の同様の処理
- 寄附者（Donor）の名寄せ・マージ機能
