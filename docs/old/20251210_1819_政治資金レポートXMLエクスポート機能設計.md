# 政治資金レポートXMLエクスポート機能 アーキテクチャ設計

## 1. 概要

政治資金収支報告書を総務省指定のXML形式でエクスポートする機能の設計書。
本ドキュメントは、レイヤリング・責務分離を中心としたアーキテクチャ設計に焦点を当てる。

### 1.1 設計の基本方針

- **責務の明確な分離**: データ取得・変換・検証・組み立て・シリアライズの各工程を独立した層に配置
- **並列実行可能な設計**: 各様式の処理を独立させ、パフォーマンスを最適化
- **テスト容易性**: 各層を疎結合にし、ユニットテスト・統合テストを容易にする

---

## 2. レイヤリング概要

本機能は、以下の4層で構成される：

```
┌─────────────────────────────────────────┐
│  Presentation層 (route.ts)              │  ← エントリーポイント
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Application層                          │
│  - Usecase                              │  ← 処理のオーケストレーション
│  - Assembler                            │  ← データ組み立て
│  - ISerializer (IF)                     │  ← シリアライズ契約
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Domain層                               │
│  - IRepository (IF)                     │  ← データアクセス抽象
│  - Converter                            │  ← データ変換ロジック
│  - Validator                            │  ← 検証ロジック
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  Infrastructure層                       │
│  - ReportSerializer (Impl)              │  ← ISerializer実装
│  - Repository (Impl)                    │  ← Prisma実装
│  - XMLBuilder                           │  ← XML構築ライブラリ
└─────────────────────────────────────────┘
```

---

## 3. 各層の責務

### 3.1 Presentation層

**役割:**
- HTTPリクエストの受付
- Usecaseの呼び出し
- HTTPレスポンスの返却

**責務:**
- リクエストパラメータの検証（基本的な型チェックのみ）
- Usecaseへのパラメータ受け渡し
- エラーハンドリング（HTTPステータスコードの決定）
- レスポンスフォーマットの整形

**責務外:**
- ビジネスロジック
- データアクセス
- データ変換

---

### 3.2 Application層

Application層は、3つのコンポーネントで構成される。

#### 3.2.1 Usecase

**役割:**
- 処理全体のオーケストレーション
- Assemblerの並列実行制御
- Serializerの呼び出し
- 最終的な出力の生成

**責務:**
- 複数のAssemblerを並列実行
- 各Assemblerの結果を統合してReportDataを生成
- ReportDataをSerializerに渡してXMLを生成
- ファイル名の生成
- エンコーディング変換（Shift_JIS）

**依存関係:**
- Assembler（複数）
- Serializer

**責務外:**
- 個別のデータ取得ロジック
- XML構造の詳細な構築
- データの変換・検証ロジック

**処理フロー:**
```
1. 入力パラメータを受け取る
   - politicalOrganizationId
   - financialYear
   - sections（出力対象の様式リスト）

2. 対象様式に対応するAssemblerを並列実行
   - Promise.allで並列化
   - 各Assemblerは独立して動作

3. 各Assemblerの結果を統合
   - ReportData構造体を生成
   - セクションデータをマージ

4. ReportDataをSerializerに渡す
   - XML文字列を取得

5. 最終出力を返却
   - xml: XMLデータ（UTF-8）
   - shiftJisBuffer: Shift_JISエンコード済みバッファ
   - filename: ファイル名
   - sectionsData: 各セクションのデータ（デバッグ用）
```

#### 3.2.2 Assembler

**役割:**
- 特定のドメイン領域（支出、寄付、収入など）のデータ組み立て
- RepositoryとDomain層サービス（Converter/Validator）の統合

**責務:**
- Repositoryからデータ取得
- Converterでドメインモデルに変換
- Validatorでデータ検証
- **ドメインモデル（ビジネスデータ）を返却**

**依存関係:**
- Repository（インターフェース）
- Converter
- Validator

**責務外:**
- **XMLの様式番号（SYUUSHI07_XX）を知らない** ← 重要
- XMLの構築（Serializerの責務）
- 様式番号へのマッピング（Serializerの責務）
- 複数Assemblerの統合（Usecaseの責務）
- データベースアクセスの詳細（Repositoryの責務）

**設計パターン:**
- Assemblerは適切な粒度で作成する
  - ドメイン領域単位で作成（「支出全般」「寄付全般」など）
  - XML様式番号（SYUUSHI07_XX）は意識しない
- 例: `OtherIncomeAssembler` → その他収入のビジネスデータを返却
- 例: `ExpenseAssembler` → 支出全般のビジネスデータを返却
- 例: `DonationAssembler` → 寄付全般のビジネスデータを返却

**返却するデータ:**
- Assemblerは**ドメインモデル**を返す
- XML様式番号へのマッピングはSerializerが行う

**ドメインモデルの設計方針:**
- **キーレベルで分ける**（type: enum ではなく）
- 各カテゴリを独立したフィールドとして持つ
- 例: ExpenseData
  ```typescript
  interface ExpenseData {
    personnelExpenses: ExpenseItem[];      // 人件費
    utilityExpenses: ExpenseItem[];        // 光熱水費
    suppliesExpenses: ExpenseItem[];       // 備品消耗品費
    officeExpenses: ExpenseItem[];         // 事務所費
    organizationExpenses: ExpenseItem[];   // 組織活動費
    electionExpenses: ExpenseItem[];       // 選挙関係費
    // ... その他の支出カテゴリ
  }
  ```
- **メリット:**
  - 型安全性が高い（各カテゴリの存在がコンパイル時に保証される）
  - Serializerでのマッピングが直感的（フィールド名 → 様式番号）
  - IDEの補完が効く
  - null/undefinedチェックが不要（空配列で統一）

**処理フロー:**
```
1. Repositoryから生データ取得
   - 政治団体ID・会計年度でフィルタリング

2. Converterでドメインモデルに変換
   - DB型 → ドメイン型
   - 金額の計算
   - カテゴリの判定

3. Validatorで検証
   - 必須項目チェック
   - 金額閾値チェック（10万円など）
   - ビジネスルールの検証

4. ドメインモデルを返却
   - 例: ExpenseData（支出データ）
   - 例: DonationData（寄付データ）
   - 様式番号は含まない
```

#### 3.2.3 Serializer（インターフェース）

**役割:**
- ReportDataをXML文字列に変換する契約を定義

**インターフェース定義:**
```typescript
interface ISerializer {
  serialize(data: ReportData): string;
}
```

**責務:**
- シリアライズのメソッドシグネチャを定義
- 実装の詳細を隠蔽

**責務外:**
- 具体的なXML構築ロジック（実装クラスの責務）

---

### 3.3 Infrastructure層

Infrastructure層は、以下のコンポーネントで構成される。

#### 3.3.1 ReportSerializer（Serializer実装）

**役割:**
- ISerializerインターフェースの具体実装
- ReportDataをXMLに変換
- XML構造の構築
- **ドメインモデルを様式番号（SYUUSHI07_XX）にマッピング**

**責務:**
- ReportDataを受け取る
- **ドメインモデルを様式番号にマッピング**
  - ExpenseData → SYUUSHI07_07～16の各様式
  - DonationData → SYUUSHI07_01～03の各様式
- XML文書全体の構造を構築
  - HEADセクション
  - SYUUSHI_FLGセクション
  - 各データセクション（様式番号付き）
- XMLBuilderを使ってXML文字列を生成

**依存関係:**
- XMLBuilder（同じInfrastructure層）

**責務外:**
- データの取得・変換・検証
- ビジネスロジック
- エンコーディング変換（Usecaseの責務）

**処理フロー:**
```
1. ReportDataを受け取る
   - head: ヘッダー情報
   - ドメインモデル（ExpenseData, DonationData, etc.）

2. ドメインモデルを様式番号にマッピング
   - ExpenseData.personnelExpenses → SYUUSHI07_07
   - ExpenseData.utilityExpenses → SYUUSHI07_08
   - DonationData.personalDonations → SYUUSHI07_01
   - （各フィールドを対応する様式番号にマッピング）

3. XML文書全体を構築
   - BOOK要素をルートに
   - HEAD要素を構築
   - SYUUSHI_FLG要素を構築（様式の有無フラグ）
   - 各データを様式番号付きXML要素に変換

4. XML文字列を返却
```

#### 3.3.2 Repository（実装）

**役割:**
- Repositoryインターフェースの具体実装
- Prismaを使ったデータベースアクセス

**責務:**
- PrismaClientを使ったクエリ実行
- WHERE句の構築
- JOIN処理
- Prisma型からドメイン型へのマッピング
- BigInt/Decimal型の変換

**責務外:**
- ビジネスロジック
- データの検証・変換ロジック

#### 3.3.3 XMLBuilder

**役割:**
- XML構築ライブラリ（xmlbuilder2）のラッピング

**責務:**
- XMLドキュメントの構築
- XML宣言（version, encoding）の設定
- 要素・属性の追加
- XML文字列の生成

**設計方針:**
- ReportSerializerから利用される低レベルAPI
- xmlbuilder2の薄いラッパーとして実装

---

### 3.4 Domain層

Domain層は、3つのコンポーネントで構成される。

#### 3.4.1 Repository（インターフェース）

**役割:**
- データアクセスの抽象化
- 様式ごとのデータ取得メソッドの定義

**責務:**
- データ取得メソッドのシグネチャ定義
- 戻り値の型定義（ドメインモデル型）

**責務外:**
- 具体的なDB操作（Infrastructure層の責務）
- ビジネスロジック

**設計方針:**
- 様式ごとに専用のメソッドを定義
- 例: `findPersonalDonationTransactions(filters): Promise<PersonalDonationTransaction[]>`
- 例: `findOtherIncomeTransactions(filters): Promise<OtherIncomeTransaction[]>`

**インターフェース例:**
```typescript
// 概念的な構造
interface ITransactionXmlRepository {
  // 各様式用のメソッド
  findPersonalDonationTransactions(filters): Promise<Transaction[]>;
  findCorporateDonationTransactions(filters): Promise<Transaction[]>;
  findOtherIncomeTransactions(filters): Promise<Transaction[]>;
  findPersonnelExpenseTransactions(filters): Promise<Transaction[]>;
  // ... 様式ごとに追加
}
```

#### 3.4.2 Converter

**役割:**
- データ形式の変換
- ビジネスロジックに基づくデータの加工

**責務:**
- DB型からドメイン型への変換
- 金額の計算（借方・貸方の判定）
- カテゴリ・ラベルの決定
- テキストの整形（サニタイズ、長さ制限）
- 日付の正規化

**責務外:**
- データの検証（Validatorの責務）
- データの取得（Repositoryの責務）
- XML構築（Serializerの責務）

**設計パターン:**
- 様式ごとに個別のConverterクラスを作成
- 純粋関数として設計（副作用なし）
- 例: `OtherIncomeConverter.convertTransaction(raw): ConvertedTransaction`

#### 3.4.3 Validator

**役割:**
- データの検証
- ビジネスルールの適用

**責務:**
- 必須項目の検証
- 金額閾値の検証（例: 10万円以上は明細記載）
- カテゴリの妥当性検証
- データの整合性チェック

**責務外:**
- データの変換（Converterの責務）
- データの取得（Repositoryの責務）

**設計パターン:**
- 様式ごとに個別のValidatorクラスを作成
- 純粋関数として設計（副作用なし）
- エラーメッセージの生成
- 例: `OtherIncomeValidator.validate(data): ValidationResult`

---

## 4. データフロー

### 4.1 全体フロー

```
[Presentation]
   route.ts
      ↓ リクエスト受付
      ↓
[Application - Usecase]
   XmlExportUsecase
      ↓ Assembler並列実行
      ├→ DonationAssembler（寄付全般を集約）
      │     ↓ Repository呼び出し
      │     ↓ [Domain - Repository IF]
      │     ↓ [Infra - Repository Impl]
      │     ↓ Prisma → DB
      │     ↑ データ取得
      │     ↓ [Domain - Converter]
      │     ↓ データ変換
      │     ↓ [Domain - Validator]
      │     ↓ 検証
      │     ↑ DonationData返却（ドメインモデル）
      │
      ├→ ExpenseAssembler（支出全般を集約）
      │     ↓ （同様の処理）
      │     ↑ ExpenseData返却（ドメインモデル）
      │
      └→ OtherIncomeAssembler（単一様式）
            ↓ （同様の処理）
            ↑ IncomeData返却（ドメインモデル）
      ↓
      ↓ ReportData生成
      ↓
[Infra - ReportSerializer]
   ReportSerializer（ISerializer実装）
      ↓ XMLBuilder利用
      ↓ XML構築
      ↑ XML文字列
      ↓
   XmlExportUsecase
      ↓ Shift_JISエンコード
      ↑ 最終出力
      ↓
[Presentation]
   route.ts
      ↓ HTTPレスポンス
```

### 4.2 主要なデータ構造

#### 4.2.1 ReportData（中間データ構造）

```typescript
// 概念的な構造
interface ReportData {
  head: XmlHead;           // ヘッダー情報
  expense?: ExpenseData;   // 支出データ（オプショナル）
  donation?: DonationData; // 寄付データ（オプショナル）
  income?: IncomeData;     // 収入データ（オプショナル）
  // ... その他のドメインデータ
}
```

**特徴:**
- Usecaseで生成される
- Assemblerの出力（ドメインモデル）を統合したもの
- **様式番号（SYUUSHI07_XX）は含まない**
- Serializerへの入力となる
- テスト・デバッグが容易

#### 4.2.2 ドメインモデル（Assemblerの返却値）

各ドメイン領域ごとに構造が異なる。

**例: ExpenseData（支出データ）**
```typescript
// 概念的な構造
interface ExpenseData {
  personnelExpenses: ExpenseItem[];      // 人件費
  utilityExpenses: ExpenseItem[];        // 光熱水費
  suppliesExpenses: ExpenseItem[];       // 備品消耗品費
  officeExpenses: ExpenseItem[];         // 事務所費
  organizationExpenses: ExpenseItem[];   // 組織活動費
  electionExpenses: ExpenseItem[];       // 選挙関係費
  // ... その他の支出カテゴリ
}

interface ExpenseItem {
  amount: number;         // 金額
  description: string;    // 摘要
  memo?: string;          // 備考
  // ... その他のフィールド
}
```

**例: DonationData（寄付データ）**
```typescript
interface DonationData {
  personalDonations: DonationItem[];    // 個人からの寄付
  corporateDonations: DonationItem[];   // 法人からの寄付
  politicalDonations: DonationItem[];   // 政治団体からの寄付
}
```

**重要:**
- **ドメインモデルは様式番号を含まない**
- Serializerが様式番号にマッピングする

---

## 5. 様式の追加方法

新しい様式を追加する際の手順（概念的）：

### 5.1 Domain層

1. **Repository インターフェースにメソッド追加**
   - `findXXXTransactions(filters): Promise<XXXTransaction[]>`

2. **Converter作成**
   - `server/lib/xml/{様式名}-converter.ts`
   - 変換ロジックを実装

3. **Validator作成**
   - `server/lib/xml/{様式名}-validator.ts`
   - 検証ロジックを実装

### 5.2 Infrastructure層

4. **Repository実装にメソッド追加**
   - Prismaクエリを実装

### 5.3 Application層

5. **Assembler作成**
   - `server/assemblers/{様式名}-assembler.ts`
   - Repository + Converter + Validator を統合

6. **SectionData型定義**
   - 様式に対応するデータ構造を定義

7. **Serializer更新**
   - 新しいSectionData型をXMLに変換するロジックを追加

8. **Usecase更新**
   - 新しいAssemblerをswitch文に追加

---

## 6. エラーハンドリング方針

### 6.1 基本方針：All or Nothing

**重要**: 政治資金収支報告書XMLは、総務省システムに提出する公式文書である。
不完全なXMLファイルは受理されず、業務エラーにつながる。

**設計方針:**
- **全てのAssemblerが成功した場合のみ、XMLを返却**
- **1つでもAssemblerが失敗した場合、全体を失敗とする**
- 部分的な成功は許容しない

### 6.2 各層のエラーハンドリング

| 層 | エラーハンドリング方針 |
|---|---------------------|
| Presentation | HTTPステータスコードに変換して返却（500 Internal Server Error） |
| Usecase | try-catchでキャッチし、エラーメッセージを整形して投げ直す |
| Assembler | エラーを投げる（catchしない） |
| Repository | エラーを投げる（catchしない） |
| Converter/Validator | バリデーションエラーは例外を投げる |

### 6.3 エラー伝播の流れ

```
[Repository] DB接続エラー発生
     ↓ throw Error
[Assembler] エラーを受け取る
     ↓ そのまま投げる（catchしない）
[Usecase] エラーを受け取る
     ↓ try-catch でキャッチ
     ↓ エラーメッセージを整形
     ↓ throw new Error("XXX様式の処理中にエラーが発生しました: ...")
[Presentation] エラーを受け取る
     ↓ HTTPステータスコード 500 を返却
     ↓ エラーメッセージをレスポンスボディに含める
```

### 6.4 並列実行時のエラーハンドリング

```typescript
// Promise.allは1つでも失敗すると全体が失敗する（望ましい挙動）
const results = await Promise.all([
  assembler1.assemble(input),  // これが失敗すると...
  assembler2.assemble(input),
  assembler3.assemble(input),
]);
// → Promise.all全体がrejectされる（All or Nothing）
```

**メリット:**
- `Promise.all` は1つでも失敗すると即座に reject される
- 追加のエラーハンドリングコードが不要
- All or Nothing の挙動が自然に実現される

---

## 7. 命名規則

### 7.1 ファイル・クラス命名

| 層 | 命名規則 | 例 |
|---|---------|---|
| Usecase | `{機能名}Usecase` | `XmlExportUsecase` |
| Assembler | `{対象}Assembler` | `ExpenseAssembler`, `DonationAssembler` |
| Serializer (IF) | `ISerializer` | `ISerializer` |
| Serializer (Impl) | `{出力形式}Serializer` | `ReportSerializer` |
| Converter | `{様式名}-converter.ts` | `personal-donation-converter.ts` |
| Validator | `{様式名}-validator.ts` | `personal-donation-validator.ts` |
| Repository (IF) | `I{エンティティ}Repository` | `ITransactionXmlRepository` |
| Repository (Impl) | `Prisma{エンティティ}Repository` | `PrismaTransactionXmlRepository` |

### 7.2 型命名

| 型の種類 | 命名規則 | 例 |
|---------|---------|---|
| ドメインモデル | `{ドメイン}Data` | `ExpenseData`, `DonationData` |
| ドメインアイテム | `{ドメイン}Item` | `ExpenseItem`, `DonationItem` |
| Input | `{UseCase名}Input` | `XmlExportInput` |
| Result | `{UseCase名}Result` | `XmlExportResult` |
