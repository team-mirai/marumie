# 貸借対照表 DDD リファクタリング設計（Phase 2）

## 目的

開発者が貸借対照表のビジネスロジックをテストしづらい状態を解消するため。

現状、`GetBalanceSheetUsecase` と `PrismaTransactionRepository` にドメインロジックが埋め込まれており、以下の課題がある：

1. **Usecase内のドメインロジック**: 固定負債計算（借入金収入 - 借入金支出）、純資産/債務超過計算がUsecase内にあり、責務分離ができていない
2. **リポジトリ内のドメインロジック**: `getLiabilityBalance` 内でBS_CATEGORIESからの負債勘定抽出と残高計算を行っている
3. **ドメインモデルの欠如**: 貸借対照表という重要なドメイン概念がモデル化されていない

---

## 対象ファイル

### 現在のファイル

| ファイル | 課題 |
|----------|------|
| `webapp/src/server/usecases/get-balance-sheet-usecase.ts` | ドメインロジック混在 |
| `webapp/src/server/repositories/prisma-transaction.repository.ts` | ビジネスロジック混在（L267-317） |
| `webapp/src/server/repositories/interfaces/transaction-repository.interface.ts` | 貸借対照表用メソッドが肥大化 |
| `webapp/src/types/balance-sheet.ts` | 型定義のみ、ロジックなし |

### 移行後のファイル

| ファイル | 責務 |
|----------|------|
| `contexts/public-finance/domain/models/balance-sheet.ts` | ドメインモデル + 純粋関数 |
| `contexts/public-finance/domain/repositories/balance-sheet-repository.interface.ts` | リポジトリインターフェース |
| `contexts/public-finance/infrastructure/repositories/prisma-balance-sheet.repository.ts` | リポジトリ実装 |
| `contexts/public-finance/application/usecases/get-balance-sheet-usecase.ts` | オーケストレーションのみ |

---

## 設計方針

### 1. ドメインモデルへのロジック集約

月別集計設計と同様の原則を適用する：

| 層 | 責務 |
|---|---|
| Infrastructure（リポジトリ） | SQLで各項目の金額を取得（SUM等の集計） |
| Domain（モデル） | 貸借対照表の計算ロジック（固定負債、純資産/債務超過） |
| Application（Usecase） | リポジトリから生データ取得 → ドメインモデルで組み立て |

**許容する処理**: SQLでの `SUM()` による集計はパフォーマンス上の理由から許容する。

---

## 詳細設計

### 1. 新しいドメインモデル

#### BalanceSheetInput - リポジトリから返される生データ

```typescript
// domain/models/balance-sheet.ts

/** リポジトリから返される貸借対照表の入力データ */
export interface BalanceSheetInput {
  /** 流動資産（最新残高スナップショットの合計） */
  currentAssets: number;
  /** 借入金収入（借入金勘定の貸方合計） */
  borrowingIncome: number;
  /** 借入金支出（借入金勘定の借方合計） */
  borrowingExpense: number;
  /** 流動負債（負債勘定の貸方 - 借方） */
  currentLiabilities: number;
}
```

#### BalanceSheet - 完成した貸借対照表

```typescript
// 既存の BalanceSheetData 型を再利用（webapp/src/types/balance-sheet.ts）
// 型は変更せず、そのまま使用する
```

#### BalanceSheet ドメインロジック（純粋関数）

```typescript
export const BalanceSheet = {
  /**
   * 入力データから貸借対照表を生成
   * - 固定資産は0（現時点で未対応）
   * - 固定負債 = 借入金収入 - 借入金支出
   * - 純資産/債務超過 = 資産合計 - 負債合計
   */
  fromInput(input: BalanceSheetInput): BalanceSheetData {
    const fixedAssets = 0;
    const fixedLiabilities = BalanceSheet.calculateFixedLiabilities(
      input.borrowingIncome,
      input.borrowingExpense
    );

    const [netAssets, debtExcess] = BalanceSheet.calculateNetAssetsAndDebtExcess(
      input.currentAssets,
      fixedAssets,
      input.currentLiabilities,
      fixedLiabilities
    );

    return {
      left: {
        currentAssets: input.currentAssets,
        fixedAssets,
        debtExcess,
      },
      right: {
        currentLiabilities: input.currentLiabilities,
        fixedLiabilities,
        netAssets,
      },
    };
  },

  /**
   * 固定負債を計算（借入金の未返済残高）
   * 借入金収入 - 借入金支出 = 残りの借入金額
   */
  calculateFixedLiabilities(borrowingIncome: number, borrowingExpense: number): number {
    return borrowingIncome - borrowingExpense;
  },

  /**
   * 純資産と債務超過を計算
   * 資産 > 負債 → 純資産あり
   * 資産 < 負債 → 債務超過
   */
  calculateNetAssetsAndDebtExcess(
    currentAssets: number,
    fixedAssets: number,
    currentLiabilities: number,
    fixedLiabilities: number
  ): [netAssets: number, debtExcess: number] {
    const totalAssets = currentAssets + fixedAssets;
    const totalLiabilities = currentLiabilities + fixedLiabilities;
    const balance = totalAssets - totalLiabilities;

    if (balance >= 0) {
      return [balance, 0];
    } else {
      return [0, Math.abs(balance)];
    }
  },
};
```

### 2. リポジトリインターフェースの分離（Interface Segregation）

貸借対照表専用のリポジトリインターフェースを作成し、`ITransactionRepository` から分離する。

```typescript
// domain/repositories/balance-sheet-repository.interface.ts

export interface IBalanceSheetRepository {
  /**
   * 流動資産を取得（各組織の最新残高スナップショットの合計）
   */
  getCurrentAssets(organizationIds: string[]): Promise<number>;

  /**
   * 借入金収入を取得（借入金勘定の貸方合計）
   */
  getBorrowingIncome(organizationIds: string[], financialYear: number): Promise<number>;

  /**
   * 借入金支出を取得（借入金勘定の借方合計）
   */
  getBorrowingExpense(organizationIds: string[], financialYear: number): Promise<number>;

  /**
   * 流動負債を取得（負債勘定の貸方 - 借方）
   */
  getCurrentLiabilities(organizationIds: string[], financialYear: number): Promise<number>;
}
```

### 3. リポジトリ実装

現在の `PrismaTransactionRepository` と `PrismaBalanceSnapshotRepository` から該当メソッドを移動。

#### 勘定科目のSSOT参照

admin の `prisma-report-transaction.repository.ts` と同様に、`shared/accounting/account-category.ts` をSSOTとして参照する。

##### categoryKey と creditAccount / debitAccount の関係

Transactionテーブルには以下の2系統のフィールドがある：

| フィールド | 値の形式 | 例 | 用途 |
|-----------|---------|-----|------|
| `creditAccount` / `debitAccount` | 日本語の勘定科目名 | "借入金", "普通預金" | 複式簿記の貸方/借方勘定 |
| `categoryKey` | 英語キー | "loans", "utilities" | UIカテゴリ表示用 |

`PL_CATEGORIES` の構造：
```typescript
"借入金": {           // ← キー = 日本語科目名 = creditAccount/debitAccount に格納される値
  key: "loans",       // ← categoryKey に格納される値
  category: "借入金",
  type: "income"
}
```

##### 定数定義

```typescript
// infrastructure/repositories/prisma-balance-sheet.repository.ts

import { PL_CATEGORIES, BS_CATEGORIES } from "@/shared/accounting/account-category";

// 勘定科目名定数（PL_CATEGORIESのキーから取得）
// creditAccount / debitAccount でのクエリに使用
const ACCOUNT_NAMES = {
  // Object.keys(PL_CATEGORIES) から "借入金" を取得する形で参照
  // ただし TypeScript の型安全性のため、明示的に定義
  LOAN: Object.keys(PL_CATEGORIES).find(
    (key) => PL_CATEGORIES[key].key === "loans"
  ) as string,  // → "借入金"
} as const;

// 負債勘定リスト（BS_CATEGORIESから抽出）
const LIABILITY_ACCOUNTS = Object.keys(BS_CATEGORIES).filter(
  (account) => BS_CATEGORIES[account].type === "liability"
);
// 結果: ["未払金/未払費用"]
```

**設計判断**:
- `PL_CATEGORIES` の英語キー（`key` プロパティ）から逆引きして日本語科目名を取得
- これにより、英語キーをSSOTとして、日本語科目名のハードコーディングを回避
- `BS_CATEGORIES` は日本語キーのみ持つため、`Object.keys()` で直接取得

#### リポジトリ実装

```typescript
export class PrismaBalanceSheetRepository implements IBalanceSheetRepository {
  constructor(private prisma: PrismaClient) {}

  async getCurrentAssets(organizationIds: string[]): Promise<number> {
    // 既存の PrismaBalanceSnapshotRepository.getTotalLatestBalanceByOrgIds と同じ実装
  }

  async getBorrowingIncome(organizationIds: string[], financialYear: number): Promise<number> {
    // creditAccount: ACCOUNT_NAMES.LOAN, transactionType: "income"
    // 既存の PrismaTransactionRepository.getBorrowingIncomeTotal と同等
  }

  async getBorrowingExpense(organizationIds: string[], financialYear: number): Promise<number> {
    // debitAccount: ACCOUNT_NAMES.LOAN, transactionType: "expense"
    // 既存の PrismaTransactionRepository.getBorrowingExpenseTotal と同等
  }

  async getCurrentLiabilities(organizationIds: string[], financialYear: number): Promise<number> {
    // debitAccount/creditAccount IN LIABILITY_ACCOUNTS
    // 既存の PrismaTransactionRepository.getLiabilityBalance と同等
  }
}
```

**設計判断**:
- `ACCOUNT_NAMES` と `LIABILITY_ACCOUNTS` はリポジトリファイル内で定義する（admin と同様のパターン）
- `BS_CATEGORIES` からの負債勘定抽出はSQLクエリ構築のための処理であり、ドメインロジックではない
- 勘定科目名の文字列を直接書くのではなく、定数経由で参照することで変更に強くする

### 4. Usecaseの簡素化

```typescript
// application/usecases/get-balance-sheet-usecase.ts

export class GetBalanceSheetUsecase {
  constructor(
    private balanceSheetRepository: IBalanceSheetRepository,
    private politicalOrganizationRepository: IPoliticalOrganizationRepository,
  ) {}

  async execute(params: GetBalanceSheetParams): Promise<GetBalanceSheetResult> {
    // 1. slugから政治団体を取得
    const organizations = await this.politicalOrganizationRepository.findBySlugs(params.slugs);
    if (organizations.length === 0) {
      throw new Error(`Political organizations with slugs "${params.slugs.join(", ")}" not found`);
    }

    const orgIds = organizations.map((org) => org.id);

    // 2. リポジトリから生データを並列取得
    const [currentAssets, borrowingIncome, borrowingExpense, currentLiabilities] =
      await Promise.all([
        this.balanceSheetRepository.getCurrentAssets(orgIds),
        this.balanceSheetRepository.getBorrowingIncome(orgIds, params.financialYear),
        this.balanceSheetRepository.getBorrowingExpense(orgIds, params.financialYear),
        this.balanceSheetRepository.getCurrentLiabilities(orgIds, params.financialYear),
      ]);

    // 3. ドメインモデルで貸借対照表を生成
    const balanceSheetData = BalanceSheet.fromInput({
      currentAssets,
      borrowingIncome,
      borrowingExpense,
      currentLiabilities,
    });

    return { balanceSheetData };
  }
}
```

---

## 既存リポジトリの扱い

### 削除するメソッド

`ITransactionRepository` から以下のメソッドを削除（貸借対照表専用リポジトリに移動）：

- `getBorrowingIncomeTotal`
- `getBorrowingExpenseTotal`
- `getLiabilityBalance`

### 残すメソッド

`IBalanceSnapshotRepository` は他の用途でも使用される可能性があるため、既存のまま残す。
貸借対照表リポジトリからは `getCurrentAssets` として同様の処理を実装する（コード重複は許容）。

---

## ファイル変更一覧

| ファイル | 変更内容 |
|----------|----------|
| `contexts/public-finance/domain/models/balance-sheet.ts` | 新規作成 |
| `contexts/public-finance/domain/repositories/balance-sheet-repository.interface.ts` | 新規作成 |
| `contexts/public-finance/infrastructure/repositories/prisma-balance-sheet.repository.ts` | 新規作成 |
| `contexts/public-finance/application/usecases/get-balance-sheet-usecase.ts` | 新規作成 |
| `webapp/src/server/usecases/get-balance-sheet-usecase.ts` | 削除（contexts以下に移動） |
| `webapp/src/server/repositories/interfaces/transaction-repository.interface.ts` | 3メソッド削除 |
| `webapp/src/server/repositories/prisma-transaction.repository.ts` | 3メソッド削除 |
| `webapp/src/server/loaders/load-top-page-data.ts` | import先変更、リポジトリ初期化変更 |

---

## テスト方針

### ドメインモデルのテスト

`BalanceSheet` の純粋関数をユニットテストで検証：

```typescript
describe("BalanceSheet", () => {
  describe("fromInput", () => {
    it("純資産ありの場合", () => {
      const result = BalanceSheet.fromInput({
        currentAssets: 1_000_000,
        borrowingIncome: 500_000,
        borrowingExpense: 200_000,
        currentLiabilities: 100_000,
      });

      expect(result.left.currentAssets).toBe(1_000_000);
      expect(result.right.fixedLiabilities).toBe(300_000); // 500k - 200k
      expect(result.right.netAssets).toBe(600_000);
      expect(result.left.debtExcess).toBe(0);
    });

    it("債務超過の場合", () => {
      const result = BalanceSheet.fromInput({
        currentAssets: 100_000,
        borrowingIncome: 1_000_000,
        borrowingExpense: 0,
        currentLiabilities: 200_000,
      });

      expect(result.right.netAssets).toBe(0);
      expect(result.left.debtExcess).toBe(1_100_000);
    });
  });

  describe("calculateFixedLiabilities", () => {
    it("借入金収入から支出を引いた値を返す", () => {
      expect(BalanceSheet.calculateFixedLiabilities(500_000, 200_000)).toBe(300_000);
    });
  });
});
```

### 既存E2Eテストの維持

`webapp/tests/server/usecases/get-balance-sheet-usecase.test.ts` の既存テストケースは、リファクタリング後も全て通ることを確認する。

---

## 期待される効果

1. **テスタビリティ向上**: `BalanceSheet.fromInput` 等の純粋関数は、リポジトリのモック不要でユニットテスト可能
2. **責務分離**: Usecaseはオーケストレーションのみ、ドメインロジックはDomain層に集約
3. **Interface Segregation**: 貸借対照表リポジトリが独立し、依存関係が明確化
4. **admin との一貫性**: レイヤー構造が admin のアーキテクチャと統一される

---

## チェックリスト

- [ ] 既存のテストが通ること
- [ ] importパスがすべて `@/` から始まる絶対パスであること
- [ ] `server-only` が適切なファイルに含まれていること
- [ ] ドメインモデルが外部依存（Prisma等）を持たないこと
- [ ] loadersがUsecaseのみを呼び出していること
- [ ] `docs/backend-architecture-guide.md` のアーキテクチャルールと整合していること
