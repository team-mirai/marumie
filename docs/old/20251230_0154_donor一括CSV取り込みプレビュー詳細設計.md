# Donor一括CSV取り込み プレビュー表示 詳細設計

## 概要

本ドキュメントは [docs/20251230_0124_donor一括CSV取り込み設計.md](20251230_0124_donor一括CSV取り込み設計.md) の全体設計を前提に、**プレビュー表示までの詳細設計**を行う。

MFクラウドCSV取り込み機能（`preview-mf-csv-usecase.ts`）の実装パターンを踏襲し、Donor CSV取り込みに適用する。

---

## 1. 処理フロー詳細

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           UI層（React コンポーネント）                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. ファイル選択 + 政治団体選択                                               │
│  2. useEffect で自動プレビュー実行                                           │
│  3. previewAction（サーバーアクション）を呼び出し                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Presentation層（サーバーアクション）                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  preview-donor-csv-action.ts                                                │
│  1. File → Buffer → String 変換                                            │
│  2. Usecase インスタンス化（DI）                                             │
│  3. Usecase.execute() 呼び出し                                              │
│  4. 結果をクライアントに返却                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Application層（Usecase）                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  PreviewDonorCsvUsecase.execute()                                           │
│  1. DonorCsvLoader.load() → DonorCsvRecord[]                               │
│  2. transaction_no 一覧を抽出                                               │
│  3. ITransactionWithDonorRepository.findByTransactionNos() で一括取得       │
│  4. DonorCsvRecordConverter.convert() → PreviewDonorCsvRow[]               │
│  5. DonorCsvValidator.validate() でバリデーション                            │
│  6. calculateDonorPreviewSummary() でサマリー計算                            │
│  7. PreviewDonorCsvResult を返却                                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 型定義

### 2.1 CSV入力型（Infrastructure層）

```typescript
// admin/src/server/contexts/report/infrastructure/donor-csv/donor-csv-record.ts

/**
 * CSVパース直後の生データ型
 * すべて string として保持（バリデーション前）
 */
export interface DonorCsvRecord {
  /** 行番号（1始まり、ヘッダー行を除く） */
  rowNumber: number;
  /** 紐付け対象の Transaction.transaction_no */
  transaction_no: string;
  /** 寄付者名 */
  name: string;
  /** 寄付者種別（individual / corporation / political_organization） */
  donorType: string;
  /** 住所（空文字の場合あり） */
  address: string;
  /** 職業（空文字の場合あり） */
  occupation: string;
}
```

### 2.2 プレビュー行モデル（Domain層）

```typescript
// admin/src/server/contexts/report/domain/models/preview-donor-csv-row.ts

import { DonorType } from "./donor";

/**
 * プレビュー行のステータス
 */
export type PreviewDonorCsvRowStatus =
  | "valid"                    // 正常（インポート可能）
  | "invalid"                  // 入力値エラー（必須項目不足、文字数超過など）
  | "transaction_not_found"    // transaction_no が存在しない
  | "type_mismatch";           // カテゴリと donorType が不整合

/**
 * プレビュー行モデル
 */
export interface PreviewDonorCsvRow {
  /** CSV行番号（1始まり） */
  rowNumber: number;

  /** 入力値 */
  transactionNo: string;
  name: string;
  donorType: DonorType | null;  // パース失敗時は null
  address: string | null;
  occupation: string | null;

  /** バリデーション結果 */
  status: PreviewDonorCsvRowStatus;
  errors: string[];

  /** 紐付け先 Transaction 情報（存在する場合） */
  transaction: {
    id: string;
    transactionDate: Date;
    categoryKey: string;
    friendlyCategory: string | null;
    debitAmount: number;
    creditAmount: number;
    debitPartner: string | null;
    creditPartner: string | null;
    /** 既存の Donor 紐付け（ある場合） */
    existingDonor: {
      id: string;
      name: string;
      donorType: DonorType;
    } | null;
  } | null;

  /** 既存 Donor との一致（name + address + donorType で検索） */
  matchingDonor: {
    id: string;
    name: string;
    donorType: DonorType;
    address: string | null;
  } | null;
}
```

### 2.3 プレビュー結果型（Application層）

```typescript
// admin/src/server/contexts/report/application/usecases/preview-donor-csv-usecase.ts

export interface PreviewDonorCsvInput {
  csvContent: string;
  politicalOrganizationId: string;
}

export interface PreviewDonorCsvSummary {
  /** 全件数 */
  total: number;
  /** 正常件数（インポート可能） */
  valid: number;
  /** 入力値エラー件数 */
  invalid: number;
  /** Transaction 未存在件数 */
  transactionNotFound: number;
  /** 種別不整合件数 */
  typeMismatch: number;
}

export interface PreviewDonorCsvResult {
  rows: PreviewDonorCsvRow[];
  summary: PreviewDonorCsvSummary;
}
```

---

## 3. Infrastructure層の実装

### 3.1 DonorCsvLoader

**配置**: `admin/src/server/contexts/report/infrastructure/donor-csv/donor-csv-loader.ts`

**責務**: CSVテキストをパースし、`DonorCsvRecord[]` を返す

**日本語ヘッダーマッピング**:

| 日本語ヘッダー | 英語カラム名 |
|---------------|-------------|
| 取引No | transaction_no |
| 寄付者名 | name |
| 寄付者種別 | donorType |
| 住所 | address |
| 職業 | occupation |

**処理内容**:
1. CSVテキストを行単位で分割
2. 1行目をヘッダーとしてパース
3. 日本語ヘッダーを英語カラム名にマッピング
4. 2行目以降をデータ行としてパース
5. 各行を `DonorCsvRecord` に変換（行番号付与）

**エラーハンドリング**:
- ヘッダーが不正な場合は例外をスロー（`throw new Error("Invalid CSV header: missing required columns")`）
- 空行はスキップ

### 3.2 DonorCsvRecordConverter

**配置**: `admin/src/server/contexts/report/infrastructure/donor-csv/donor-csv-record-converter.ts`

**責務**: `DonorCsvRecord` を `PreviewDonorCsvRow` の初期状態に変換

**処理内容**:
1. 文字列のトリム処理
2. donorType の文字列を `DonorType` 型に変換（無効な値は `null`）
3. 空文字を `null` に変換（address, occupation）
4. 初期ステータスを `"valid"` に設定（後続バリデーションで更新）

```typescript
import { parseDonorType } from "@/server/contexts/report/domain/models/donor";

export class DonorCsvRecordConverter {
  convert(record: DonorCsvRecord): PreviewDonorCsvRow {
    const trimmedName = record.name.trim();
    const trimmedAddress = record.address.trim() || null;
    const trimmedOccupation = record.occupation.trim() || null;

    // donorType のパース（ドメインモデルのヘルパー関数を使用）
    const donorType = parseDonorType(record.donorType);

    return {
      rowNumber: record.rowNumber,
      transactionNo: record.transaction_no.trim(),
      name: trimmedName,
      donorType,
      address: trimmedAddress,
      occupation: trimmedOccupation,
      status: "valid",
      errors: [],
      transaction: null,
      matchingDonor: null,
    };
  }
}
```

---

## 4. Domain層の実装

### 4.1 DonorCsvValidator

**配置**: `admin/src/server/contexts/report/domain/services/donor-csv-validator.ts`

**責務**: `PreviewDonorCsvRow[]` に対してバリデーションを実行し、ステータスとエラーを更新

**バリデーション項目と優先順位**:

| 優先度 | チェック項目 | ステータス | エラーメッセージ例 |
|-------|-------------|-----------|-------------------|
| 1 | transaction_no 必須 | invalid | "取引Noは必須です" |
| 2 | name 必須 | invalid | "寄付者名は必須です" |
| 3 | donorType 必須・有効性 | invalid | "寄付者種別は必須です" / "寄付者種別が不正です" |
| 4 | name 文字数（120文字） | invalid | "寄付者名は120文字以内で入力してください" |
| 5 | address 文字数（120文字） | invalid | "住所は120文字以内で入力してください" |
| 6 | occupation 文字数（50文字） | invalid | "職業は50文字以内で入力してください" |
| 7 | 個人の場合 occupation 必須 | invalid | "個人の寄付者の場合、職業は必須です" |
| 8 | 法人/政治団体の場合 occupation 禁止 | invalid | "法人・政治団体の場合、職業は指定できません" |
| 9 | Transaction 存在チェック | transaction_not_found | "取引No '{no}' が見つかりません" |
| 10 | カテゴリ整合性 | type_mismatch | "カテゴリ '{category}' に対して寄付者種別 '{type}' は指定できません" |

**処理フロー**:

```typescript
import { isDonorTypeAllowedForCategory } from "@/server/contexts/report/domain/models/donor-assignment-rules";
import { DONOR_TYPE_LABELS } from "@/server/contexts/report/domain/models/donor";

export class DonorCsvValidator {
  validate(
    rows: PreviewDonorCsvRow[],
    transactionMap: Map<string, TransactionForDonorCsv>,
  ): PreviewDonorCsvRow[] {
    // 1. CSV内の transaction_no 重複を検出
    const duplicateMap = this.buildDuplicateMap(rows);

    // 2. 各行をバリデーション
    return rows.map((row) => this.validateRow(row, transactionMap, duplicateMap));
  }

  /**
   * transaction_no ごとの行番号マップを構築
   * 重複がある transaction_no のみをマップに含める
   */
  private buildDuplicateMap(rows: PreviewDonorCsvRow[]): Map<string, number[]> {
    const transactionNoToRows = new Map<string, number[]>();

    for (const row of rows) {
      const existing = transactionNoToRows.get(row.transactionNo) ?? [];
      existing.push(row.rowNumber);
      transactionNoToRows.set(row.transactionNo, existing);
    }

    // 重複（2件以上）のみを残す
    const duplicateMap = new Map<string, number[]>();
    for (const [transactionNo, rowNumbers] of transactionNoToRows) {
      if (rowNumbers.length > 1) {
        duplicateMap.set(transactionNo, rowNumbers);
      }
    }
    return duplicateMap;
  }

  private validateRow(
    row: PreviewDonorCsvRow,
    transactionMap: Map<string, TransactionForDonorCsv>,
    duplicateMap: Map<string, number[]>,
  ): PreviewDonorCsvRow {
    const errors: string[] = [];

    // 0. CSV内重複チェック（最優先）
    const duplicateRows = duplicateMap.get(row.transactionNo);
    if (duplicateRows) {
      const otherRows = duplicateRows.filter((n) => n !== row.rowNumber);
      return {
        ...row,
        status: "invalid",
        errors: [`取引No '${row.transactionNo}' が重複しています（行 ${duplicateRows.join(", ")}）`],
      };
    }

    // 1. 入力値バリデーション（validateDonorInput 相当）
    errors.push(...this.validateInputValues(row));

    if (errors.length > 0) {
      return { ...row, status: "invalid", errors };
    }

    // 2. Transaction 存在チェック
    const transaction = transactionMap.get(row.transactionNo);
    if (!transaction) {
      return {
        ...row,
        status: "transaction_not_found",
        errors: [`取引No '${row.transactionNo}' が見つかりません`],
      };
    }

    // 3. カテゴリ整合性チェック（既存ドメインモデルを使用）
    // isDonorTypeAllowedForCategory は donor-assignment-rules.ts で定義済み
    if (!isDonorTypeAllowedForCategory(transaction.categoryKey, row.donorType!)) {
      return {
        ...row,
        status: "type_mismatch",
        errors: [
          `カテゴリ '${transaction.friendlyCategory || transaction.categoryKey}' に対して` +
          `寄付者種別 '${DONOR_TYPE_LABELS[row.donorType!]}' は指定できません`,
        ],
        transaction: this.mapTransaction(transaction),
      };
    }

    // 4. 正常
    return {
      ...row,
      status: "valid",
      errors: [],
      transaction: this.mapTransaction(transaction),
    };
  }
}
```

### 4.4 カテゴリと donorType の整合性ルール

**既存実装**: `admin/src/server/contexts/report/domain/models/donor-assignment-rules.ts`

カテゴリごとに許可される donorType は既存のドメインモデルで定義済み。本機能では `isDonorTypeAllowedForCategory()` 関数を再利用する。

| カテゴリ | 許可される donorType |
|---------|---------------------|
| 個人からの寄附 | individual |
| 個人からの寄附（特定寄附） | individual |
| 法人その他の団体からの寄附 | corporation |
| 政治団体からの寄附 | political_organization |
| 寄附のあっせんによるもの | individual, corporation, political_organization |
| 政治資金パーティーの対価に係る収入 | individual, corporation, political_organization |

### 4.2 TransactionForDonorCsv 型

**配置**: `admin/src/server/contexts/report/domain/models/preview-donor-csv-row.ts`

```typescript
/**
 * Donor CSV バリデーションに必要な Transaction 情報
 */
export interface TransactionForDonorCsv {
  id: string;
  transactionNo: string;
  transactionDate: Date;
  categoryKey: string;
  friendlyCategory: string | null;
  debitAmount: number;
  creditAmount: number;
  debitPartner: string | null;
  creditPartner: string | null;
  existingDonor: {
    id: string;
    name: string;
    donorType: DonorType;
  } | null;
}
```

### 4.3 サマリー計算

**配置**: `admin/src/server/contexts/report/domain/services/donor-csv-summary-calculator.ts`

```typescript
export function calculateDonorPreviewSummary(
  rows: PreviewDonorCsvRow[],
): PreviewDonorCsvSummary {
  return {
    total: rows.length,
    valid: rows.filter((row) => row.status === "valid").length,
    invalid: rows.filter((row) => row.status === "invalid").length,
    transactionNotFound: rows.filter((row) => row.status === "transaction_not_found").length,
    typeMismatch: rows.filter((row) => row.status === "type_mismatch").length,
  };
}
```

---

## 5. Application層の実装

### 5.1 PreviewDonorCsvUsecase

**配置**: `admin/src/server/contexts/report/application/usecases/preview-donor-csv-usecase.ts`

**依存関係**:
- `DonorCsvLoader`（Infrastructure）
- `DonorCsvRecordConverter`（Infrastructure）
- `DonorCsvValidator`（Domain Service）
- `ITransactionWithDonorRepository`（Domain Interface）
- `IDonorRepository`（Domain Interface）

**処理フロー**:

```typescript
export class PreviewDonorCsvUsecase {
  constructor(
    private readonly csvLoader: DonorCsvLoader,
    private readonly recordConverter: DonorCsvRecordConverter,
    private readonly validator: DonorCsvValidator,
    private readonly transactionRepository: ITransactionWithDonorRepository,
    private readonly donorRepository: IDonorRepository,
  ) {}

  async execute(input: PreviewDonorCsvInput): Promise<PreviewDonorCsvResult> {
    try {
      // 1. CSVパース
      const csvRecords = this.csvLoader.load(input.csvContent);

      // 2. プレビュー行に変換
      const rows = csvRecords.map((record) => this.recordConverter.convert(record));

      // 3. transaction_no 一覧を抽出
      const transactionNos = [...new Set(rows.map((row) => row.transactionNo))];

      // 4. Transaction 一括取得（既存 Donor 情報含む）
      const transactions = await this.transactionRepository.findByTransactionNosForDonorCsv(
        transactionNos,
        input.politicalOrganizationId,
      );
      const transactionMap = new Map(
        transactions.map((t) => [t.transactionNo, t]),
      );

      // 5. 既存 Donor 検索（バッチ処理で N+1 問題を回避）
      const rowsWithMatchingDonor = await this.enrichWithMatchingDonors(rows);

      // 6. バリデーション
      const validatedRows = this.validator.validate(rowsWithMatchingDonor, transactionMap);

      // 7. サマリー計算
      const summary = calculateDonorPreviewSummary(validatedRows);

      return { rows: validatedRows, summary };
    } catch (error) {
      // CSVパースエラー、DBエラー等は上位層で処理
      throw new Error(`プレビュー処理に失敗しました: ${error instanceof Error ? error.message : "不明なエラー"}`);
    }
  }

  /**
   * 既存 Donor との照合を行う
   * N+1 問題を回避するため、ユニークな組み合わせを抽出し、1回のクエリで一括検索する
   */
  private async enrichWithMatchingDonors(
    rows: PreviewDonorCsvRow[],
  ): Promise<PreviewDonorCsvRow[]> {
    // 有効な donorType を持つ行から、ユニークな (name, address, donorType) の組み合わせを抽出
    const searchKeys = new Map<string, { name: string; address: string | null; donorType: DonorType }>();

    for (const row of rows) {
      if (row.donorType === null) continue;
      const key = `${row.name}|${row.address ?? ""}|${row.donorType}`;
      if (!searchKeys.has(key)) {
        searchKeys.set(key, { name: row.name, address: row.address, donorType: row.donorType });
      }
    }

    // 1回のクエリで一括検索
    const uniqueCriteria = [...searchKeys.values()];
    const donors = await this.donorRepository.findByMatchCriteriaBatch(uniqueCriteria);

    // 検索結果を Map に変換（O(1) ルックアップ用）
    const donorMap = new Map(
      donors.map((d) => [`${d.name}|${d.address ?? ""}|${d.donorType}`, d]),
    );

    // 各行に検索結果を紐付け
    return rows.map((row) => {
      if (row.donorType === null) return row;

      const key = `${row.name}|${row.address ?? ""}|${row.donorType}`;
      const matchingDonor = donorMap.get(key);

      return {
        ...row,
        matchingDonor: matchingDonor
          ? {
              id: matchingDonor.id,
              name: matchingDonor.name,
              donorType: matchingDonor.donorType,
              address: matchingDonor.address,
            }
          : null,
      };
    });
  }
}
```

**エラーハンドリング方針**:
- CSVパースエラー: 例外をスローし、Presentation層でユーザーにエラーメッセージを表示
- DB接続エラー: 例外をスローし、Presentation層でリトライを促すメッセージを表示
- 部分成功: 対応しない（全体成功または全体失敗）

### 5.2 リポジトリ拡張（IDonorRepository）

**追加メソッド**:

```typescript
// admin/src/server/contexts/report/domain/repositories/donor-repository.interface.ts

export interface IDonorRepository {
  // ... 既存メソッド

  /**
   * 複数の (name, address, donorType) 条件で既存 Donor を一括検索
   *
   * 同一人物判定に使用。政治資金報告書では同一寄付者の寄付を合算して
   * 5万円以上かを判定する必要があるため、既存Donorとの照合が重要。
   *
   * @param criteria 検索条件の配列
   * @returns 条件に一致した Donor の配列（一致しない条件は結果に含まれない）
   */
  findByMatchCriteriaBatch(
    criteria: Array<{ name: string; address: string | null; donorType: DonorType }>
  ): Promise<Donor[]>;
}
```

### 5.3 リポジトリ拡張（ITransactionWithDonorRepository）

**追加メソッド**:

```typescript
// admin/src/server/contexts/report/domain/repositories/transaction-with-donor-repository.interface.ts

export interface ITransactionWithDonorRepository {
  // ... 既存メソッド

  /**
   * Donor CSV 取り込み用: transaction_no で Transaction を一括取得
   * 既存の Donor 紐付け情報も含む
   */
  findByTransactionNosForDonorCsv(
    transactionNos: string[],
    politicalOrganizationId: string,
  ): Promise<TransactionForDonorCsv[]>;
}
```

#### IDonorRepository 実装方針

```typescript
// admin/src/server/contexts/report/infrastructure/repositories/donor-repository.ts

async findByMatchCriteriaBatch(
  criteria: Array<{ name: string; address: string | null; donorType: DonorType }>
): Promise<Donor[]> {
  if (criteria.length === 0) return [];

  // PostgreSQL のタプル比較で一括検索（1クエリ）
  // WHERE (name, COALESCE(address, ''), donor_type) IN ((...), (...), ...)
  const donors = await this.prisma.$queryRaw<Donor[]>`
    SELECT * FROM donor
    WHERE (name, COALESCE(address, ''), donor_type) IN (
      ${Prisma.join(
        criteria.map(c =>
          Prisma.sql`(${c.name}, ${c.address ?? ''}, ${c.donorType})`
        )
      )}
    )
  `;
  return donors;
}
```

**パフォーマンス考慮**:
- K 回の個別クエリではなく、1 回の IN 句クエリで一括取得
- 1000行制限の制約下で、タプル比較は PostgreSQL で効率的に処理可能
- `(name, address, donor_type)` の複合インデックスがあるとより効率的（なくても動作する）

**将来の最適化案**:
- 同一人物判定の精度向上が必要になった場合、match_hash カラムを導入して
  ハッシュベースの検索に切り替えることを検討
- その場合、正規化ロジック（trim + 全角半角統一）はリポジトリ実装の内部詳細として扱う

#### ITransactionWithDonorRepository 実装方針

```typescript
// admin/src/server/contexts/report/infrastructure/repositories/transaction-with-donor-repository.ts

async findByTransactionNosForDonorCsv(
  transactionNos: string[],
  politicalOrganizationId: string,
): Promise<TransactionForDonorCsv[]> {
  // Prisma Query: findMany で transaction_no IN (...) を使用
  const transactions = await this.prisma.transaction.findMany({
    where: {
      transactionNo: { in: transactionNos },
      politicalOrganizationId,
    },
    include: {
      // LEFT JOIN: transaction が Donor に紐付いていない場合も結果に含める
      donor: true,
    },
    orderBy: {
      transactionNo: "asc",
    },
  });

  // 入力の transaction_no 順序を保持するため、結果をマップしてソート
  const transactionMap = new Map(
    transactions.map((t) => [t.transactionNo, t]),
  );

  return transactionNos
    .map((no) => transactionMap.get(no))
    .filter((t): t is NonNullable<typeof t> => t !== undefined)
    .map((t) => ({
      id: t.id,
      transactionNo: t.transactionNo,
      transactionDate: t.transactionDate,
      categoryKey: t.categoryKey,
      friendlyCategory: t.friendlyCategory,
      debitAmount: t.debitAmount,
      creditAmount: t.creditAmount,
      debitPartner: t.debitPartner,
      creditPartner: t.creditPartner,
      // null 安全性: LEFT JOIN の結果が null の場合は null として扱う
      existingDonor: t.donor
        ? {
            id: t.donor.id,
            name: t.donor.name,
            donorType: t.donor.donorType as DonorType,
          }
        : null,
    }));
}
```

**パフォーマンス考慮**:
- 1000行制限の制約下で、`IN` 句による一括クエリは PostgreSQL で効率的に処理可能
- `transactionNo` カラムにはインデックスが設定されている前提
- 入力順序を保持するため、クエリ結果をメモリ上で再ソート

---

## 6. Presentation層の実装

### 6.1 サーバーアクション

**配置**: `admin/src/server/contexts/report/presentation/actions/preview-donor-csv-action.ts`

```typescript
"use server";

import "server-only";
import { PreviewDonorCsvResult } from "@/server/contexts/report/application/usecases/preview-donor-csv-usecase";

export interface PreviewDonorCsvRequest {
  file: File;
  politicalOrganizationId: string;
}

export async function previewDonorCsv(
  request: PreviewDonorCsvRequest,
): Promise<PreviewDonorCsvResult> {
  const { file, politicalOrganizationId } = request;

  // 1. File → String 変換
  const csvBuffer = Buffer.from(await file.arrayBuffer());
  const csvContent = bufferToString(csvBuffer);

  // 2. DI: Usecase インスタンス化
  const csvLoader = new DonorCsvLoader();
  const recordConverter = new DonorCsvRecordConverter();
  const validator = new DonorCsvValidator();
  const transactionRepository = new TransactionWithDonorRepository(prisma);
  const donorRepository = new DonorRepository(prisma);

  const usecase = new PreviewDonorCsvUsecase(
    csvLoader,
    recordConverter,
    validator,
    transactionRepository,
    donorRepository,
  );

  // 3. Usecase 実行
  try {
    const result = await usecase.execute({
      csvContent,
      politicalOrganizationId,
    });

    return result;
  } catch (error) {
    // エラー分類とユーザーフレンドリーなメッセージへの変換
    console.error("Preview CSV error:", error);

    if (error instanceof Error) {
      // CSVフォーマットエラー
      if (error.message.includes("Invalid CSV") || error.message.includes("CSVの行数が上限")) {
        throw new Error("CSVファイルの形式が正しくありません。テンプレートを確認してください");
      }
      // DB接続・クエリエラー
      if (error.message.includes("Failed to") || error.message.includes("失敗")) {
        throw new Error("処理に失敗しました。時間をおいて再度お試しください");
      }
    }
    throw new Error("予期しないエラーが発生しました");
  }
}
```

---

## 7. UI層の実装

### 7.1 ページ構成

**配置**: `admin/src/app/(auth)/import-donors/page.tsx`

```
import-donors/
└── page.tsx           # ページコンポーネント（サーバーコンポーネント）
```

**クライアントコンポーネント**:

```
admin/src/client/components/donor-csv-import/
├── DonorCsvImportClient.tsx    # メインクライアントコンポーネント
├── DonorCsvPreview.tsx         # プレビュー表示コンポーネント
├── DonorCsvSummary.tsx         # サマリー表示コンポーネント
└── DonorCsvRow.tsx             # 行表示コンポーネント
```

### 7.2 DonorCsvImportClient

**状態管理**:
- `file: File | null` - 選択されたファイル
- `politicalOrganizationId: string` - 選択された政治団体
- `previewResult: PreviewDonorCsvResult | null` - プレビュー結果
- `loading: boolean` - プレビュー実行中フラグ

**処理フロー**:
1. ファイル選択 + 政治団体選択
2. `useEffect` で自動プレビュー実行
3. プレビュー結果を表示
4. 「インポート実行」ボタン（全件 valid の場合のみ有効）

### 7.3 DonorCsvPreview

**表示項目**:

| 列名 | 説明 |
|-----|------|
| 行番号 | CSV行番号 |
| ステータス | valid / invalid / transaction_not_found / type_mismatch |
| 取引No | transaction_no |
| 寄付者名 | name |
| 寄付者種別 | donorType（日本語ラベル） |
| 住所 | address |
| 職業 | occupation |
| 取引日 | Transaction の日付（存在する場合） |
| カテゴリ | Transaction のカテゴリ（存在する場合） |
| 金額 | creditAmount（収入なので貸方） |
| エラー | errors 配列をリスト表示 |

**タブフィルター**:
- 全件
- 正常（valid）
- エラー（invalid）
- 取引なし（transaction_not_found）
- 種別不整合（type_mismatch）

**ステータス色分け**:

| ステータス | 背景色 | テキスト |
|-----------|-------|---------|
| valid | bg-green-500/20 | 正常 |
| invalid | bg-red-500/20 | エラー |
| transaction_not_found | bg-yellow-500/20 | 取引なし |
| type_mismatch | bg-orange-500/20 | 種別不整合 |

### 7.4 DonorCsvSummary

**表示内容**:

```
┌────────────────────────────────────────────────┐
│  全件数: 100件                                  │
│  ├─ 正常: 85件                                 │
│  ├─ エラー: 5件                                │
│  ├─ 取引なし: 7件                              │
│  └─ 種別不整合: 3件                            │
└────────────────────────────────────────────────┘
```

---

## 8. ファイル一覧

### 新規作成ファイル

| パス | 責務 |
|-----|------|
| `report/infrastructure/donor-csv/donor-csv-record.ts` | CSV入力型定義 |
| `report/infrastructure/donor-csv/donor-csv-loader.ts` | CSVパーサー |
| `report/infrastructure/donor-csv/donor-csv-record-converter.ts` | Record→Row変換 |
| `report/domain/models/preview-donor-csv-row.ts` | プレビュー行モデル |
| `report/domain/services/donor-csv-validator.ts` | バリデーションサービス |
| `report/domain/services/donor-csv-summary-calculator.ts` | サマリー計算 |
| `report/application/usecases/preview-donor-csv-usecase.ts` | プレビューUsecase |
| `report/presentation/actions/preview-donor-csv-action.ts` | サーバーアクション |
| `app/(auth)/import-donors/page.tsx` | ページ |
| `client/components/donor-csv-import/DonorCsvImportClient.tsx` | メインクライアント |
| `client/components/donor-csv-import/DonorCsvPreview.tsx` | プレビュー表示 |
| `client/components/donor-csv-import/DonorCsvSummary.tsx` | サマリー表示 |
| `client/components/donor-csv-import/DonorCsvRow.tsx` | 行表示 |

### 修正ファイル

| パス | 変更内容 |
|-----|---------|
| `report/domain/repositories/donor-repository.interface.ts` | `findByMatchCriteriaBatch` メソッド追加 |
| `report/infrastructure/repositories/donor-repository.ts` | 上記メソッドの実装（タプル比較で1クエリ） |
| `report/domain/repositories/transaction-with-donor-repository.interface.ts` | `findByTransactionNosForDonorCsv` メソッド追加 |
| `report/infrastructure/repositories/transaction-with-donor-repository.ts` | 上記メソッドの実装 |

---

## 9. 考慮事項への対応

### 9.1 CSV内重複（同一 transaction_no が複数行）

**方針**: エラーとして扱う

**実装**:
- `DonorCsvValidator` で CSV内の transaction_no 重複をチェック
- 重複行は `status: "invalid"`, `errors: ["取引No '{no}' が重複しています（行 {n1}, {n2}）"]`

### 9.2 既存紐付けの表示

**方針**: プレビュー画面で既存の Donor 紐付けを表示し、上書きされることをユーザーに明示

**実装**:
- `PreviewDonorCsvRow.transaction.existingDonor` に既存 Donor 情報を格納
- UI で「既存: {name}」→「新規: {name}」のような表示

### 9.3 大量データ対応

**方針**: 1000行制限を設ける

**実装**:
- `DonorCsvLoader` で行数チェック
- 1000行を超える場合は例外をスロー（`throw new Error("CSVの行数が上限（1000行）を超えています")`）

---

## 10. 前提条件

本設計は [docs/backend-architecture-guide.md](backend-architecture-guide.md) のアーキテクチャルールに準拠している。

実装時に以下を確認すること：

- Presentation層はUsecaseのみを呼び出し、ビジネスロジックを含まない
- Application層（Usecase）はリポジトリインターフェースに依存し、実装クラスに直接依存しない
- Domain層は他のレイヤーに依存しない
- Infrastructure層はドメインインターフェースを実装する
- コンテキスト間で直接依存しない（shared経由のみ）
- actionsで適切に`revalidatePath`を呼び出す（プレビューは読み取り専用のため不要）
