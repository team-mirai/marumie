# 寄付者CSVインポート確定フェーズ設計

## 目的

**管理者が5000件以上の寄付者情報を1件ずつ手動入力する必要がある困りごとを解消するため**、CSVプレビュー後のインポート確定機能を提供する。

---

## 1. 概要

既に実装済みのプレビューフェーズに続き、ユーザーが「インポート実行」ボタンをクリックした際の処理を設計する。

### 処理フロー

```
┌──────────────────────────────────────────────────────────────────┐
│                      インポート確定フェーズ                         │
├──────────────────────────────────────────────────────────────────┤
│  1. ユーザーが「インポート実行」ボタンをクリック                      │
│  2. クライアントからサーバーアクションを呼び出し                      │
│     - 再度CSV内容をパース＆バリデーション                            │
│     - valid行のみを抽出                                            │
│  3. Donorの作成または既存Donor検索                                  │
│     - matchingDonor がある行: 既存Donorを使用                       │
│     - matchingDonor がない行: 新規Donor作成                         │
│  4. TransactionDonorの一括紐付け                                   │
│  5. キャッシュ無効化                                                │
│  6. 結果をtoastで通知                                               │
│     - 成功: "○件のインポートが完了しました"                          │
│     - 失敗: "インポートに失敗しました: {エラー内容}"                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## 2. UI設計

### 2.1 インポートボタン

プレビュー結果の下に「インポート実行」ボタンを配置する。

| 条件 | ボタンの状態 |
|------|------------|
| 1件以上が valid | 有効 (enabled) |
| valid が 0件 | 無効 (disabled) |
| インポート処理中 | 無効 + ローディング表示 |

ボタンには件数を表示する：
- 「○件をインポート」（valid行数を表示）

**注意**: エラー行（invalid/transaction_not_found/type_mismatch）はスキップされ、valid行のみがインポートされる。

### 2.2 toast通知

sonnerを使用した通知を表示する。

**成功時:**
```typescript
toast.success(`${importedCount}件のインポートが完了しました`);
```

**失敗時:**
```typescript
toast.error(`インポートに失敗しました: ${errorMessage}`);
```

### 2.3 インポート成功後の動作

1. toast.success で成功通知を表示
2. ファイル入力をリセット（プレビュー結果もクリア）
3. 画面遷移は行わない（同じ画面で続けてインポートできるようにする）

---

## 3. アーキテクチャ

### 3.1 新規作成ファイル

```
report/
├── presentation/
│   └── actions/
│       └── import-donor-csv.ts              # サーバーアクション（新規）
├── application/
│   └── usecases/
│       └── import-donor-csv-usecase.ts      # インポートUsecase（新規）
├── domain/
│   └── repositories/
│       └── transaction-manager.ts           # トランザクション管理インターフェース（新規）
└── infrastructure/
    └── repositories/
        └── prisma-transaction-manager.ts    # トランザクション管理実装（新規）
```

### 3.2 既存ファイルへのメソッド追加

```
report/
├── domain/
│   └── repositories/
│       ├── donor-repository.ts              # createMany メソッド追加
│       └── transaction-donor-repository.ts  # bulkUpsert メソッド追加
└── infrastructure/
    └── repositories/
        ├── prisma-donor-repository.ts       # createMany 実装追加
        └── prisma-transaction-donor-repository.ts # bulkUpsert 実装追加
```

### 3.3 UIコンポーネントの変更

```
client/components/donor-csv-import/
├── DonorCsvImportClient.tsx           # インポートボタン追加
└── DonorCsvPreview.tsx                # インポートボタンのUI追加
```

---

## 4. 各レイヤーの責務

### 4.1 Presentation層（import-donor-csv.ts）

サーバーアクションとして以下を実行：

1. リクエストの受け取り（csvContent: string, politicalOrganizationId: string）
   - **注意**: File オブジェクトはサーバーアクションでシリアライズ不可のため、クライアント側で `file.text()` により string に変換してから渡す
2. ImportDonorCsvUsecase の呼び出し
3. 成功時: `revalidatePath("/import/donors")` でキャッシュ無効化
4. エラーハンドリング: ユーザーフレンドリーなメッセージに変換

**戻り値型:**
```typescript
type ImportDonorCsvResult =
  | { ok: true; importedCount: number; createdDonorCount: number }
  | { ok: false; error: string };
```

### 4.2 Application層（ImportDonorCsvUsecase）

**入力:**
```typescript
interface ImportDonorCsvInput {
  csvContent: string;
  politicalOrganizationId: string;
}
```

**出力:**
```typescript
interface ImportDonorCsvOutput {
  importedCount: number;      // 紐付けしたTransaction数
  createdDonorCount: number;  // 新規作成したDonor数
}
```

**処理フロー:**

1. PreviewDonorCsvUsecase と同様のパース＆バリデーション
2. valid行が0件の場合は例外をスロー
3. valid行のみを抽出してインポート対象とする
4. 同一 transaction_no の重複解決（後勝ち）
5. **トランザクション内で以下を実行:**
   1. 新規Donorの一括作成（バルクインサート）
   2. TransactionDonorの一括紐付け（バルク操作）

#### 5.1 新規Donorの一括作成（詳細）

```typescript
// 1. matchingDonor がない行を抽出
const rowsNeedingNewDonor = validRows.filter(row => !row.matchingDonor);

// 2. CSV内で同一Donorの重複を除去（Map で一意化）
//    キー: `${name}|${address}|${donorType}`
const uniqueDonorMap = new Map<string, DonorCreateInput>();
for (const row of rowsNeedingNewDonor) {
  const key = `${row.name}|${row.address}|${row.donorType}`;
  uniqueDonorMap.set(key, { name: row.name, address: row.address, donorType: row.donorType, ... });
}
const uniqueDonors = Array.from(uniqueDonorMap.values());

// 3. バルクインサート（N+1回避）
const createdDonors = await donorRepository.createMany(uniqueDonors);
```

#### 5.2 TransactionDonor紐付け（詳細）

```typescript
// 1. 各行に対応するDonorIdを解決
//    - matchingDonor がある行: matchingDonor.id を使用
//    - matchingDonor がない行: 5.1で作成したDonorをMapから参照
const transactionDonorPairs: { transactionId: string; donorId: string }[] = [];
for (const row of validRows) {
  const donorId = row.matchingDonor?.id ?? createdDonorMap.get(key)!.id;
  transactionDonorPairs.push({ transactionId: row.transactionId, donorId });
}

// 2. バルクupsert（Raw SQL INSERT ... ON CONFLICT により1クエリで実行）
await transactionDonorRepository.bulkUpsert(transactionDonorPairs);
```

#### トランザクション境界の設計

```typescript
// Usecase 内でトランザクションを管理
async execute(input: ImportDonorCsvInput): Promise<ImportDonorCsvOutput> {
  // 1-4: トランザクション外でバリデーション・データ準備
  const validRows = await this.prepareValidRows(input);

  // 5: トランザクション内で書き込み処理
  return await this.transactionManager.execute(async (tx) => {
    // 5.1: Donorバルクインサート
    const createdDonors = await this.donorRepository.createMany(uniqueDonors, tx);

    // 5.2: TransactionDonor upsert
    await this.transactionDonorRepository.bulkUpsert(transactionDonorPairs, tx);

    return { importedCount, createdDonorCount };
  });
}
```

**トランザクション保証:**
- Donor作成とTransactionDonor紐付けは同一トランザクション内で実行
- いずれかの処理が失敗した場合、全ての変更がロールバック
- 部分的な状態（Donorだけ作成されてTransactionDonorが紐付いていない等）は発生しない

**依存インターフェース:**
- IDonorCsvLoader
- IDonorCsvRecordConverter
- IDonorCsvValidator
- ITransactionWithDonorRepository
- IDonorRepository（createMany メソッドを追加）
- ITransactionDonorRepository（bulkUpsert メソッドを追加）
- ITransactionManager（トランザクション管理）

### 4.3 Domain層

本機能で使用するドメインモデルとドメインサービスは、既存の実装を再利用する。

**使用するドメインモデル:**
- `Donor`: 寄付者エンティティ（name + address + donorType で同一人物を識別）
- `PreviewDonorCsvRow`: CSVプレビュー行の値オブジェクト（status, errors, matchingDonor を保持）

**ドメイン不変条件:**
- Donor の一意性: name + address + donorType の組み合わせで一意
- TransactionDonor: 1つの Transaction に対して1つの Donor のみ紐付け可能

**ドメインサービス（既存を再利用）:**
- `DonorCsvValidator`: CSV行のバリデーション、カテゴリとdonorTypeの整合性チェック

### 4.4 Infrastructure層（リポジトリ実装）

本機能で追加が必要なリポジトリメソッドの仕様を定義する。

#### IDonorRepository.createMany

```typescript
interface IDonorRepository {
  // 既存メソッド...

  /**
   * 複数のDonorを一括作成する（N+1回避のためのバルクインサート）
   * @param donors 作成するDonorの配列
   * @param tx トランザクションコンテキスト（Prisma.$transaction 内で使用）
   * @returns 作成されたDonorの配列（IDを含む）
   */
  createMany(donors: DonorCreateInput[], tx?: PrismaTransactionClient): Promise<Donor[]>;
}
```

**Prisma実装（N+1回避）:**
```typescript
async createMany(donors: DonorCreateInput[], tx?: PrismaTransactionClient): Promise<Donor[]> {
  const client = tx ?? this.prisma;

  // createManyReturning を使用（Prisma 5.14.0+）
  // 対応していない場合は createMany + findMany で2クエリに抑える
  const created = await client.donor.createManyAndReturn({
    data: donors.map(d => ({
      id: generateId(),
      name: d.name,
      address: d.address,
      donorType: d.donorType,
      politicalOrganizationId: d.politicalOrganizationId,
    })),
  });

  return created.map(toDomainModel);
}
```

#### ITransactionDonorRepository.bulkUpsert

```typescript
interface ITransactionDonorRepository {
  // 既存メソッド...

  /**
   * 複数のTransactionに対するDonor紐付けを一括でupsertする
   * - 既存の紐付けがあれば donorId を更新（created_at は保持）
   * - 既存の紐付けがなければ新規作成
   * @param pairs TransactionIdとDonorIdのペア配列
   * @param tx トランザクションコンテキスト
   */
  bulkUpsert(
    pairs: { transactionId: string; donorId: string }[],
    tx?: PrismaTransactionClient
  ): Promise<void>;
}
```

**実装（Raw SQL による1クエリ upsert）:**

Prismaには `upsertMany` が存在しないため、PostgreSQLの `INSERT ... ON CONFLICT` を使用して1クエリで処理する。
5000件を個別upsertすると5000クエリ発生し、レイテンシ・タイムアウトのリスクがあるため、Raw SQLを採用する。

```typescript
async bulkUpsert(
  pairs: { transactionId: string; donorId: string }[],
  tx?: PrismaTransactionClient
): Promise<void> {
  if (pairs.length === 0) return;

  const client = tx ?? this.prisma;

  // VALUES句を構築
  const valuesClauses: string[] = [];
  const params: string[] = [];

  pairs.forEach((pair, i) => {
    const txIdParam = i * 2 + 1;
    const donorIdParam = i * 2 + 2;
    valuesClauses.push(`($${txIdParam}, $${donorIdParam}, NOW(), NOW())`);
    params.push(pair.transactionId, pair.donorId);
  });

  const sql = `
    INSERT INTO "TransactionDonor" ("transactionId", "donorId", "createdAt", "updatedAt")
    VALUES ${valuesClauses.join(', ')}
    ON CONFLICT ("transactionId")
    DO UPDATE SET
      "donorId" = EXCLUDED."donorId",
      "updatedAt" = NOW()
  `;

  await client.$executeRawUnsafe(sql, ...params);
}
```

**Raw SQL採用の理由:**
- 5000件でも1クエリで完了（Prisma upsertだと5000クエリ）
- `ON CONFLICT DO UPDATE` により `createdAt` は既存レコードの値が保持される
- パラメータ化クエリによりSQLインジェクション対策済み

**注意点:**
- テーブル名・カラム名はPrismaスキーマと一致させること
- PostgreSQL固有の構文のため、DB変更時は要修正

#### ITransactionManager（トランザクション管理）

```typescript
interface ITransactionManager {
  /**
   * トランザクション内で処理を実行する
   * 失敗時は自動ロールバック
   */
  execute<T>(fn: (tx: PrismaTransactionClient) => Promise<T>): Promise<T>;
}
```

**Prisma実装:**
```typescript
class PrismaTransactionManager implements ITransactionManager {
  constructor(private readonly prisma: PrismaClient) {}

  async execute<T>(fn: (tx: PrismaTransactionClient) => Promise<T>): Promise<T> {
    return this.prisma.$transaction(async (tx) => {
      return fn(tx);
    }, {
      // 5000件のバルク処理に対応するためタイムアウトを延長
      timeout: 30000, // 30秒
      isolationLevel: 'ReadCommitted',
    });
  }
}
```

**クエリ数の見積もり:**
| 処理 | クエリ数 | 備考 |
|------|---------|------|
| Donor一括作成 | 1 | createManyAndReturn |
| TransactionDonor upsert | 1 | Raw SQL `INSERT ... ON CONFLICT` |
| **合計** | **2** | 5000件でも2クエリ |

※ Raw SQLにより、5000件処理でも2クエリで完了

### 4.5 Client層（DonorCsvImportClient.tsx / DonorCsvPreview.tsx）

DonorCsvPreview に以下を追加：
- インポートボタン（件数表示付き）
- ローディング状態の管理
- インポートアクションの呼び出し（File → string 変換後に呼び出し）
- toast通知の表示

DonorCsvImportClient に以下を追加：
- インポート成功時のファイルリセット処理

---

## 5. 考慮事項の決定

既存設計ドキュメント（docs/20251230_0124_donor一括CSV取り込み設計.md）で検討事項として挙げられていた項目について、本設計での方針を記載する。

### 5.1 CSVファイル内の重複（同一transaction_no）

**方針: 後勝ち**

同一のtransaction_noが複数行ある場合、最後の行で上書きする。

**処理順序:**
1. CSVをパースして全行を取得
2. transaction_no でグループ化し、同一 transaction_no の行は最後の行のみを残す（後勝ち）
3. 残った行に対して Donor の重複除去を実施

**具体例:**
```
CSV行1: transaction_no=001, name=山田太郎, donorType=individual
CSV行2: transaction_no=001, name=山田花子, donorType=individual  ← この行が採用される（後勝ち）
CSV行3: transaction_no=002, name=山田太郎, donorType=individual
```
結果: transaction_no=001 は「山田花子」、transaction_no=002 は「山田太郎」で紐付け

理由:
- ユーザーがCSVを編集して再アップロードする際、末尾に修正行を追加するケースが多い
- エラーとすると、ユーザーにCSV修正を強いることになり使い勝手が悪い

### 5.2 既存紐付けの扱い

**方針: 置換（既存設計通り）**

`ITransactionDonorRepository.replaceMany()` により、インポート対象のTransactionの既存紐付けは新しい紐付けに置換される。

### 5.3 大量データ対応

**方針: 5000行まで**

- プレビュー時に5000行を超える場合はエラーを表示
- 既存のDonorCsvValidator にチェック処理を追加

---

## 6. エラーハンドリング

### 6.1 例外型とエラーマッピング

| 例外型 | 発生箇所 | Presentation層での対応 |
|--------|---------|----------------------|
| `NoValidRowsError` | Usecase | `{ ok: false, error: "インポート可能な行がありません" }` |
| `CsvFormatError` | Infrastructure | `{ ok: false, error: "CSVファイルの形式が正しくありません" }` |
| `PrismaClientKnownRequestError` | Repository | `{ ok: false, error: "データベースへの保存に失敗しました。時間をおいて再試行してください" }` |
| `Error`（その他） | 任意 | `{ ok: false, error: "予期しないエラーが発生しました" }` |

### 6.2 Presentation層のエラーハンドリングパターン

```typescript
try {
  const result = await usecase.execute(input);
  revalidatePath("/import/donors");
  return { ok: true, ...result };
} catch (error) {
  if (error instanceof NoValidRowsError) {
    return { ok: false, error: "インポート可能な行がありません" };
  }
  if (error instanceof CsvFormatError) {
    return { ok: false, error: "CSVファイルの形式が正しくありません" };
  }
  // DB関連エラー
  if (error instanceof Error && error.message.includes("database")) {
    return { ok: false, error: "データベースへの保存に失敗しました。時間をおいて再試行してください" };
  }
  return { ok: false, error: "予期しないエラーが発生しました" };
}
```

---

## 7. テスト

### 7.1 Unit テスト（ImportDonorCsvUsecase）

ファイル: `admin/src/server/contexts/report/application/usecases/__tests__/import-donor-csv-usecase.test.ts`

**テストケース:**
- 正常系: valid行のみインポートされる
- 正常系: 新規Donorが作成される
- 正常系: 既存Donorが再利用される（matchingDonor あり）
- 後勝ち: 同一transaction_noは最後の行が採用される
- 重複除去: 同一Donor（name + address + donorType）は1回のみ作成
- エラー: valid行が0件の場合は例外
- エラー: 5000行超過時は例外

**モック:**
- IDonorCsvLoader, IDonorCsvRecordConverter, IDonorCsvValidator
- IDonorRepository, ITransactionDonorRepository, ITransactionWithDonorRepository

### 7.2 E2Eテスト

既存のE2Eテストファイル（`admin/e2e/tests/import-donors.spec.ts`）に以下のテストケースを追加する。

**インポートボタンの表示**
- 1件以上がvalidの場合、インポートボタンが有効になる
- valid件数が0件の場合、インポートボタンが無効になる

**インポート実行**
- インポートボタンをクリックすると成功toastが表示される
- インポート成功後、ファイル入力がリセットされる
- インポート成功後、プレビューが消える

### 7.3 テストデータ

既存のサンプルCSV（`data/sample_donor_import.csv`）を使用。必要に応じて、全件validなテスト用CSVを追加する。

---

## 8. チェックリスト（実装時に確認）

### アーキテクチャ
- [ ] Presentation層はUsecaseのみを呼び出し、ビジネスロジックを含んでいない
- [ ] Application層（Usecase）はリポジトリインターフェースに依存し、実装クラスに依存していない
- [ ] actionsで適切に`revalidatePath`を呼び出している

### トランザクション整合性
- [ ] Donor作成とTransactionDonor紐付けが同一トランザクション内で実行されている
- [ ] トランザクション失敗時に全ての変更がロールバックされることを確認
- [ ] 部分的な状態が発生しないことをテストで検証

### N+1問題の回避
- [ ] `IDonorRepository.createMany` がバルクインサートを使用している（1クエリ）
- [ ] `ITransactionDonorRepository.bulkUpsert` が Raw SQL `INSERT ... ON CONFLICT` を使用している（1クエリ）
- [ ] 5000件処理時のクエリ数が2であることを確認

### UI/UX
- [ ] toast通知が成功/失敗で適切に表示される
- [ ] ファイル入力がインポート成功後にリセットされる
- [ ] 5000行制限のバリデーションが機能している

### テスト
- [ ] Unit テストが全て通る
- [ ] E2Eテストが全て通る
- [ ] トランザクションロールバックのテストケースが存在する
